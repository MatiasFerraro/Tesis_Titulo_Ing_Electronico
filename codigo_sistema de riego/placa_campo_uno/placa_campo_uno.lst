CCS PCH C Compiler, Version 5.015, 5967               22-abr-15 07:10

               Filename:   D:\Users\matias-pc\Desktop\_back_1\TESIS_SISTEMA_RIEGO_ARCHIVOS_PROTOTIPO\sistema_riego_tesis_placas_nueva-v31\placa_campo_uno\placa_campo_uno.lst

               ROM used:   6960 bytes (21%)
                           Largest free fragment is 25804
               RAM used:   235 (11%) at main() level
                           287 (14%) worst case
               Stack used: 6 locations (2 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   19B8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   00D8
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... //CAMPO uno 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 30,30
00B2:  DATA 30,30
00B4:  DATA 30,30
00B6:  DATA 30,31
00B8:  DATA 00,00
00BA:  MOVFF  FF2,0D
00BE:  BCF    FF2.7
00C0:  CLRF   FF7
00C2:  ADDLW  D4
00C4:  MOVWF  FF6
00C6:  MOVLW  00
00C8:  ADDWFC FF7,F
00CA:  TBLRD*+
00CC:  MOVF   FF5,W
00CE:  BTFSC  0D.7
00D0:  BSF    FF2.7
00D2:  RETURN 0
00D4:  DATA DD,00
00D6:  DATA E4,00
*
0908:  MOVLW  8E
090A:  MOVWF  00
090C:  MOVFF  10E,01
0910:  MOVFF  10D,02
0914:  CLRF   03
0916:  MOVF   01,F
0918:  BNZ   092C
091A:  MOVFF  02,01
091E:  CLRF   02
0920:  MOVLW  08
0922:  SUBWF  00,F
0924:  MOVF   01,F
0926:  BNZ   092C
0928:  CLRF   00
092A:  BRA    093C
092C:  BCF    FD8.0
092E:  BTFSC  01.7
0930:  BRA    093A
0932:  RLCF   02,F
0934:  RLCF   01,F
0936:  DECF   00,F
0938:  BRA    092C
093A:  BCF    01.7
093C:  RETURN 0
093E:  MOVLB  1
0940:  MOVF   x0D,W
0942:  BTFSC  FD8.2
0944:  BRA    0A28
0946:  MOVWF  00
0948:  MOVF   x11,W
094A:  BTFSC  FD8.2
094C:  BRA    0A28
094E:  ADDWF  00,F
0950:  BNC   095A
0952:  MOVLW  81
0954:  ADDWF  00,F
0956:  BC    0A28
0958:  BRA    0962
095A:  MOVLW  7F
095C:  SUBWF  00,F
095E:  BNC   0A28
0960:  BZ    0A28
0962:  MOVFF  10E,115
0966:  MOVF   x12,W
0968:  XORWF  x15,F
096A:  BSF    x0E.7
096C:  BSF    x12.7
096E:  MOVF   x10,W
0970:  MULWF  x14
0972:  MOVFF  FF4,117
0976:  MOVF   x0F,W
0978:  MULWF  x13
097A:  MOVFF  FF4,03
097E:  MOVFF  FF3,116
0982:  MULWF  x14
0984:  MOVF   FF3,W
0986:  ADDWF  x17,F
0988:  MOVF   FF4,W
098A:  ADDWFC x16,F
098C:  MOVLW  00
098E:  ADDWFC 03,F
0990:  MOVF   x10,W
0992:  MULWF  x13
0994:  MOVF   FF3,W
0996:  ADDWF  x17,F
0998:  MOVF   FF4,W
099A:  ADDWFC x16,F
099C:  MOVLW  00
099E:  CLRF   02
09A0:  ADDWFC 03,F
09A2:  ADDWFC 02,F
09A4:  MOVF   x0E,W
09A6:  MULWF  x14
09A8:  MOVF   FF3,W
09AA:  ADDWF  x16,F
09AC:  MOVF   FF4,W
09AE:  ADDWFC 03,F
09B0:  MOVLW  00
09B2:  ADDWFC 02,F
09B4:  MOVF   x0E,W
09B6:  MULWF  x13
09B8:  MOVF   FF3,W
09BA:  ADDWF  03,F
09BC:  MOVF   FF4,W
09BE:  ADDWFC 02,F
09C0:  MOVLW  00
09C2:  CLRF   01
09C4:  ADDWFC 01,F
09C6:  MOVF   x10,W
09C8:  MULWF  x12
09CA:  MOVF   FF3,W
09CC:  ADDWF  x16,F
09CE:  MOVF   FF4,W
09D0:  ADDWFC 03,F
09D2:  MOVLW  00
09D4:  ADDWFC 02,F
09D6:  ADDWFC 01,F
09D8:  MOVF   x0F,W
09DA:  MULWF  x12
09DC:  MOVF   FF3,W
09DE:  ADDWF  03,F
09E0:  MOVF   FF4,W
09E2:  ADDWFC 02,F
09E4:  MOVLW  00
09E6:  ADDWFC 01,F
09E8:  MOVF   x0E,W
09EA:  MULWF  x12
09EC:  MOVF   FF3,W
09EE:  ADDWF  02,F
09F0:  MOVF   FF4,W
09F2:  ADDWFC 01,F
09F4:  INCF   00,F
09F6:  BTFSC  01.7
09F8:  BRA    0A04
09FA:  RLCF   x16,F
09FC:  RLCF   03,F
09FE:  RLCF   02,F
0A00:  RLCF   01,F
0A02:  DECF   00,F
0A04:  MOVLW  00
0A06:  BTFSS  x16.7
0A08:  BRA    0A1E
0A0A:  INCF   03,F
0A0C:  ADDWFC 02,F
0A0E:  ADDWFC 01,F
0A10:  MOVF   01,W
0A12:  BNZ   0A1E
0A14:  MOVF   02,W
0A16:  BNZ   0A1E
0A18:  MOVF   03,W
0A1A:  BNZ   0A1E
0A1C:  INCF   00,F
0A1E:  BTFSC  x15.7
0A20:  BSF    01.7
0A22:  BTFSS  x15.7
0A24:  BCF    01.7
0A26:  BRA    0A30
0A28:  CLRF   00
0A2A:  CLRF   01
0A2C:  CLRF   02
0A2E:  CLRF   03
0A30:  MOVLB  0
0A32:  RETURN 0
0A34:  MOVLB  1
0A36:  MOVF   x11,W
0A38:  BTFSC  FD8.2
0A3A:  BRA    0B86
0A3C:  MOVWF  x1D
0A3E:  MOVF   x15,W
0A40:  BTFSC  FD8.2
0A42:  BRA    0B86
0A44:  SUBWF  x1D,F
0A46:  BNC   0A52
0A48:  MOVLW  7F
0A4A:  ADDWF  x1D,F
0A4C:  BTFSC  FD8.0
0A4E:  BRA    0B86
0A50:  BRA    0A5E
0A52:  MOVLW  81
0A54:  SUBWF  x1D,F
0A56:  BTFSS  FD8.0
0A58:  BRA    0B86
0A5A:  BTFSC  FD8.2
0A5C:  BRA    0B86
0A5E:  MOVFF  11D,00
0A62:  CLRF   01
0A64:  CLRF   02
0A66:  CLRF   03
0A68:  CLRF   x1C
0A6A:  MOVFF  112,11B
0A6E:  BSF    x1B.7
0A70:  MOVFF  113,11A
0A74:  MOVFF  114,119
0A78:  MOVLW  19
0A7A:  MOVWF  x1D
0A7C:  MOVF   x18,W
0A7E:  SUBWF  x19,F
0A80:  BC    0A9C
0A82:  MOVLW  01
0A84:  SUBWF  x1A,F
0A86:  BC    0A9C
0A88:  SUBWF  x1B,F
0A8A:  BC    0A9C
0A8C:  SUBWF  x1C,F
0A8E:  BC    0A9C
0A90:  INCF   x1C,F
0A92:  INCF   x1B,F
0A94:  INCF   x1A,F
0A96:  MOVF   x18,W
0A98:  ADDWF  x19,F
0A9A:  BRA    0AEC
0A9C:  MOVF   x17,W
0A9E:  SUBWF  x1A,F
0AA0:  BC    0AC6
0AA2:  MOVLW  01
0AA4:  SUBWF  x1B,F
0AA6:  BC    0AC6
0AA8:  SUBWF  x1C,F
0AAA:  BC    0AC6
0AAC:  INCF   x1C,F
0AAE:  INCF   x1B,F
0AB0:  MOVF   x17,W
0AB2:  ADDWF  x1A,F
0AB4:  MOVF   x18,W
0AB6:  ADDWF  x19,F
0AB8:  BNC   0AEC
0ABA:  INCF   x1A,F
0ABC:  BNZ   0AEC
0ABE:  INCF   x1B,F
0AC0:  BNZ   0AEC
0AC2:  INCF   x1C,F
0AC4:  BRA    0AEC
0AC6:  MOVF   x16,W
0AC8:  IORLW  80
0ACA:  SUBWF  x1B,F
0ACC:  BC    0AEA
0ACE:  MOVLW  01
0AD0:  SUBWF  x1C,F
0AD2:  BC    0AEA
0AD4:  INCF   x1C,F
0AD6:  MOVF   x16,W
0AD8:  IORLW  80
0ADA:  ADDWF  x1B,F
0ADC:  MOVF   x17,W
0ADE:  ADDWF  x1A,F
0AE0:  BNC   0AB4
0AE2:  INCF   x1B,F
0AE4:  BNZ   0AB4
0AE6:  INCF   x1C,F
0AE8:  BRA    0AB4
0AEA:  BSF    03.0
0AEC:  DECFSZ x1D,F
0AEE:  BRA    0AF2
0AF0:  BRA    0B08
0AF2:  BCF    FD8.0
0AF4:  RLCF   x19,F
0AF6:  RLCF   x1A,F
0AF8:  RLCF   x1B,F
0AFA:  RLCF   x1C,F
0AFC:  BCF    FD8.0
0AFE:  RLCF   03,F
0B00:  RLCF   02,F
0B02:  RLCF   01,F
0B04:  RLCF   x1E,F
0B06:  BRA    0A7C
0B08:  BTFSS  x1E.0
0B0A:  BRA    0B18
0B0C:  BCF    FD8.0
0B0E:  RRCF   01,F
0B10:  RRCF   02,F
0B12:  RRCF   03,F
0B14:  RRCF   x1E,F
0B16:  BRA    0B1C
0B18:  DECF   00,F
0B1A:  BZ    0B86
0B1C:  BTFSC  x1E.7
0B1E:  BRA    0B5C
0B20:  BCF    FD8.0
0B22:  RLCF   x19,F
0B24:  RLCF   x1A,F
0B26:  RLCF   x1B,F
0B28:  RLCF   x1C,F
0B2A:  MOVF   x18,W
0B2C:  SUBWF  x19,F
0B2E:  BC    0B3E
0B30:  MOVLW  01
0B32:  SUBWF  x1A,F
0B34:  BC    0B3E
0B36:  SUBWF  x1B,F
0B38:  BC    0B3E
0B3A:  SUBWF  x1C,F
0B3C:  BNC   0B72
0B3E:  MOVF   x17,W
0B40:  SUBWF  x1A,F
0B42:  BC    0B4E
0B44:  MOVLW  01
0B46:  SUBWF  x1B,F
0B48:  BC    0B4E
0B4A:  SUBWF  x1C,F
0B4C:  BNC   0B72
0B4E:  MOVF   x16,W
0B50:  IORLW  80
0B52:  SUBWF  x1B,F
0B54:  BC    0B5C
0B56:  MOVLW  01
0B58:  SUBWF  x1C,F
0B5A:  BNC   0B72
0B5C:  INCF   03,F
0B5E:  BNZ   0B72
0B60:  INCF   02,F
0B62:  BNZ   0B72
0B64:  INCF   01,F
0B66:  BNZ   0B72
0B68:  INCF   00,F
0B6A:  BZ    0B86
0B6C:  RRCF   01,F
0B6E:  RRCF   02,F
0B70:  RRCF   03,F
0B72:  MOVFF  112,11D
0B76:  MOVF   x16,W
0B78:  XORWF  x1D,F
0B7A:  BTFSS  x1D.7
0B7C:  BRA    0B82
0B7E:  BSF    01.7
0B80:  BRA    0B8E
0B82:  BCF    01.7
0B84:  BRA    0B8E
0B86:  CLRF   00
0B88:  CLRF   01
0B8A:  CLRF   02
0B8C:  CLRF   03
0B8E:  MOVLB  0
0B90:  RETURN 0
*
0D56:  MOVLW  8E
0D58:  MOVWF  00
0D5A:  MOVLB  1
0D5C:  MOVF   x0D,W
0D5E:  SUBWF  00,F
0D60:  MOVFF  10E,02
0D64:  MOVFF  10F,01
0D68:  BSF    02.7
0D6A:  MOVF   00,F
0D6C:  BZ    0D80
0D6E:  BCF    FD8.0
0D70:  MOVF   02,F
0D72:  BNZ   0D78
0D74:  MOVF   01,F
0D76:  BZ    0D80
0D78:  RRCF   02,F
0D7A:  RRCF   01,F
0D7C:  DECFSZ 00,F
0D7E:  BRA    0D6E
0D80:  BTFSS  x0E.7
0D82:  BRA    0D8E
0D84:  COMF   01,F
0D86:  COMF   02,F
0D88:  INCF   01,F
0D8A:  BTFSC  FD8.2
0D8C:  INCF   02,F
0D8E:  MOVLB  0
0D90:  RETURN 0
*
0F4E:  MOVFF  DC,FEA
0F52:  MOVFF  DB,FE9
0F56:  MOVLB  1
0F58:  MOVFF  116,FEF
0F5C:  INCF   FE9,F
0F5E:  BTFSC  FD8.2
0F60:  INCF   FEA,F
0F62:  CLRF   FEF
0F64:  MOVLB  0
0F66:  INCF   xDB,F
0F68:  BTFSC  FD8.2
0F6A:  INCF   xDC,F
0F6C:  RETURN 0
0F6E:  MOVFF  FEA,115
0F72:  MOVFF  FE9,114
0F76:  MOVLB  1
0F78:  SWAPF  x0E,W
0F7A:  IORLW  F0
0F7C:  MOVWF  x10
0F7E:  ADDWF  x10,F
0F80:  ADDLW  E2
0F82:  MOVWF  x11
0F84:  ADDLW  32
0F86:  MOVWF  x13
0F88:  MOVF   x0E,W
0F8A:  ANDLW  0F
0F8C:  ADDWF  x11,F
0F8E:  ADDWF  x11,F
0F90:  ADDWF  x13,F
0F92:  ADDLW  E9
0F94:  MOVWF  x12
0F96:  ADDWF  x12,F
0F98:  ADDWF  x12,F
0F9A:  SWAPF  x0D,W
0F9C:  ANDLW  0F
0F9E:  ADDWF  x12,F
0FA0:  ADDWF  x13,F
0FA2:  RLCF   x12,F
0FA4:  RLCF   x13,F
0FA6:  COMF   x13,F
0FA8:  RLCF   x13,F
0FAA:  MOVF   x0D,W
0FAC:  ANDLW  0F
0FAE:  ADDWF  x13,F
0FB0:  RLCF   x10,F
0FB2:  MOVLW  07
0FB4:  MOVWF  x0F
0FB6:  MOVLW  0A
0FB8:  DECF   x12,F
0FBA:  ADDWF  x13,F
0FBC:  BNC   0FB8
0FBE:  DECF   x11,F
0FC0:  ADDWF  x12,F
0FC2:  BNC   0FBE
0FC4:  DECF   x10,F
0FC6:  ADDWF  x11,F
0FC8:  BNC   0FC4
0FCA:  DECF   x0F,F
0FCC:  ADDWF  x10,F
0FCE:  BNC   0FCA
0FD0:  MOVLW  01
0FD2:  MOVWF  FEA
0FD4:  MOVLW  0F
0FD6:  MOVWF  FE9
0FD8:  MOVLW  07
0FDA:  ANDWF  x14,W
0FDC:  BCF    x14.6
0FDE:  ADDWF  FE9,F
0FE0:  MOVLW  00
0FE2:  ADDWFC FEA,F
0FE4:  MOVF   FE9,W
0FE6:  SUBLW  13
0FE8:  BNZ   0FF0
0FEA:  DECFSZ FEA,W
0FEC:  BRA    0FF0
0FEE:  BSF    x14.6
0FF0:  MOVF   FEF,W
0FF2:  MOVWF  00
0FF4:  BNZ   1006
0FF6:  BTFSC  x14.6
0FF8:  BRA    1006
0FFA:  BTFSC  x14.4
0FFC:  BRA    1028
0FFE:  BTFSC  x14.3
1000:  BRA    1006
1002:  MOVLW  20
1004:  BRA    100C
1006:  BSF    x14.3
1008:  BCF    x14.4
100A:  MOVLW  30
100C:  ADDWF  00,F
100E:  MOVFF  FEA,10E
1012:  MOVFF  FE9,10D
1016:  MOVFF  00,116
101A:  MOVLB  0
101C:  RCALL  0F4E
101E:  MOVFF  10E,FEA
1022:  MOVFF  10D,FE9
1026:  MOVLB  1
1028:  MOVF   FEE,W
102A:  BTFSS  x14.6
102C:  BRA    0FE4
102E:  MOVLB  0
1030:  RETURN 0
*
10A4:  MOVLB  1
10A6:  MOVF   x10,W
10A8:  CLRF   01
10AA:  SUBWF  x0F,W
10AC:  BC    10B4
10AE:  MOVFF  10F,00
10B2:  BRA    10CC
10B4:  CLRF   00
10B6:  MOVLW  08
10B8:  MOVWF  x11
10BA:  RLCF   x0F,F
10BC:  RLCF   00,F
10BE:  MOVF   x10,W
10C0:  SUBWF  00,W
10C2:  BTFSC  FD8.0
10C4:  MOVWF  00
10C6:  RLCF   01,F
10C8:  DECFSZ x11,F
10CA:  BRA    10BA
10CC:  MOVLB  0
10CE:  RETURN 0
10D0:  MOVF   01,W
10D2:  MOVFF  10D,10F
10D6:  MOVLW  64
10D8:  MOVLB  1
10DA:  MOVWF  x10
10DC:  MOVLB  0
10DE:  RCALL  10A4
10E0:  MOVFF  00,10D
10E4:  MOVF   01,W
10E6:  MOVLW  30
10E8:  BNZ   10FA
10EA:  MOVLB  1
10EC:  BTFSS  x0E.1
10EE:  BRA    110E
10F0:  BTFSC  x0E.3
10F2:  BRA    110E
10F4:  BTFSC  x0E.4
10F6:  MOVLW  20
10F8:  BRA    1102
10FA:  MOVLB  1
10FC:  BCF    x0E.3
10FE:  BCF    x0E.4
1100:  BSF    x0E.0
1102:  ADDWF  01,F
1104:  MOVFF  01,116
1108:  MOVLB  0
110A:  RCALL  0F4E
110C:  MOVLB  1
110E:  MOVFF  10D,10F
1112:  MOVLW  0A
1114:  MOVWF  x10
1116:  MOVLB  0
1118:  RCALL  10A4
111A:  MOVFF  00,10D
111E:  MOVF   01,W
1120:  MOVLW  30
1122:  BNZ   1134
1124:  MOVLB  1
1126:  BTFSC  x0E.3
1128:  BRA    113E
112A:  BTFSS  x0E.0
112C:  BRA    113E
112E:  BTFSC  x0E.4
1130:  MOVLW  20
1132:  MOVLB  0
1134:  ADDWF  01,F
1136:  MOVFF  01,116
113A:  RCALL  0F4E
113C:  MOVLB  1
113E:  MOVLW  30
1140:  ADDWF  x0D,F
1142:  MOVFF  10D,116
1146:  MOVLB  0
1148:  RCALL  0F4E
114A:  GOTO   1398 (RETURN)
*
1708:  MOVLB  1
170A:  MOVF   x0E,W
170C:  ANDLW  07
170E:  MOVWF  00
1710:  RRCF   x0E,W
1712:  MOVWF  01
1714:  RRCF   01,F
1716:  RRCF   01,F
1718:  MOVLW  1F
171A:  ANDWF  01,F
171C:  MOVF   01,W
171E:  ADDWF  x10,W
1720:  MOVWF  FE9
1722:  MOVLW  00
1724:  ADDWFC x11,W
1726:  MOVWF  FEA
1728:  CLRF   01
172A:  INCF   01,F
172C:  INCF   00,F
172E:  BRA    1732
1730:  RLCF   01,F
1732:  DECFSZ 00,F
1734:  BRA    1730
1736:  MOVF   x0F,F
1738:  BZ    1740
173A:  MOVF   01,W
173C:  IORWF  FEF,F
173E:  BRA    1746
1740:  COMF   01,F
1742:  MOVF   01,W
1744:  ANDWF  FEF,F
1746:  MOVLB  0
1748:  RETURN 0
*
1986:  MOVFF  FF2,0D
198A:  BCF    FF2.7
198C:  ADDWF  FE8,W
198E:  CLRF   FF7
1990:  RLCF   FF7,F
1992:  ADDLW  AB
1994:  MOVWF  FF6
1996:  MOVLW  19
1998:  ADDWFC FF7,F
199A:  TBLRD*-
199C:  MOVF   FF5,W
199E:  MOVWF  FFA
19A0:  TBLRD*
19A2:  MOVF   FF5,W
19A4:  BTFSC  0D.7
19A6:  BSF    FF2.7
19A8:  MOVWF  FF9
19AA:  DATA AE,17
19AC:  DATA B4,17
19AE:  DATA 0E,18
19B0:  DATA 6A,18
19B2:  DATA 80,18
19B4:  DATA B0,18
19B6:  DATA 10,19
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #FUSES NOMCLR 
.................... #FUSES PUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES PLL1                     //No PLL PreScaler 
.................... #FUSES CPUDIV1                  //No System Clock Postscaler 
.................... #FUSES NOUSBDIV                 //USB clock source comes from primary oscillator 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #use delay(clock=20000000) 
*
011A:  MOVLW  01
011C:  MOVWF  FEA
011E:  MOVLW  0D
0120:  MOVWF  FE9
0122:  MOVF   FEF,W
0124:  BZ    0140
0126:  MOVLW  06
0128:  MOVWF  01
012A:  CLRF   00
012C:  DECFSZ 00,F
012E:  BRA    012C
0130:  DECFSZ 01,F
0132:  BRA    012A
0134:  MOVLW  7B
0136:  MOVWF  00
0138:  DECFSZ 00,F
013A:  BRA    0138
013C:  DECFSZ FEF,F
013E:  BRA    0126
0140:  RETURN 0
*
015E:  MOVLW  03
0160:  MOVLB  1
0162:  SUBWF  x11,F
0164:  BNC   017A
0166:  MOVLW  01
0168:  MOVWF  FEA
016A:  MOVLW  11
016C:  MOVWF  FE9
016E:  MOVF   FEF,W
0170:  BZ    017A
0172:  BRA    0176
0174:  BRA    0176
0176:  DECFSZ FEF,F
0178:  BRA    0174
017A:  MOVLB  0
017C:  GOTO   019C (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8, stop=2,stream=PORT1,enable=PIN_D3)//56800 
0180:  BCF    F95.3
0182:  BSF    F8C.3
0184:  BTFSS  F9E.4
0186:  BRA    0184
0188:  BCF    F95.3
018A:  BSF    F8C.3
018C:  MOVLB  1
018E:  MOVF   x10,W
0190:  MOVWF  FAD
0192:  BTFSS  FAC.1
0194:  BRA    0192
0196:  CLRF   x11
0198:  MOVLB  0
019A:  BRA    015E
019C:  NOP   
019E:  BTFSS  FAC.1
01A0:  BRA    019E
01A2:  BCF    F95.3
01A4:  BCF    F8C.3
01A6:  GOTO   01D2 (RETURN)
.................... #include <adc.c> 
.................... //agregar en codigo principal ---->#device adc=10 
.................... int16 AN_0,AN_1,AN_2,AN_3; 
.................... float AN0_V,AN1_V,AN2_V,AN3_V; 
.................... int AN_0_porcentaje,AN_1_porcentaje,AN_2_porcentaje,AN_3_porcentaje; 
.................... adc_init() 
.................... { 
....................   /*enable_interrupts(global); 
....................   enable_interrupts(int_rda); 
....................   setup_adc_ports(ALL_ANALOG); 
....................   setup_adc(ADC_CLOCK_INTERNAL);  
....................   */ 
....................   setup_adc_ports(AN0_TO_AN4|VSS_VREF);  
*
0142:  MOVF   FC1,W
0144:  ANDLW  C0
0146:  IORLW  1A
0148:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_INTERNAL);  
014A:  MOVF   FC0,W
014C:  ANDLW  C0
014E:  IORLW  07
0150:  MOVWF  FC0
0152:  BSF    FC0.7
0154:  BSF    FC2.0
....................   enable_interrupts(global); 
0156:  MOVLW  C0
0158:  IORWF  FF2,F
015A:  GOTO   13F6 (RETURN)
....................   /* setup_adc(ADC_CLOCK_Div_8); 
....................   setup_psp(PSP_DISABLED);  
....................   setup_spi(SPI_SS_DISABLED);  
....................   setup_wdt(WDT_OFF);  
....................   setup_timer_0(RTCC_INTERNAL);  
....................   setup_timer_1(T1_DISABLED);  
....................   setup_timer_2(T2_DIV_BY_1,60,5);  
....................   setup_timer_3(T3_DISABLED|T3_DIV_BY_1);  
....................   setup_comparator(NC_NC_NC_NC);  
....................  */ 
....................  
.................... } 
.................... void leer_ADC0_ADC1_ADC2_ADC3() 
.................... { 
....................     
....................    
....................   set_adc_channel(0); //habilitacion canal 0 
*
0874:  MOVLW  00
0876:  MOVWF  01
0878:  MOVF   FC2,W
087A:  ANDLW  C3
087C:  IORWF  01,W
087E:  MOVWF  FC2
....................   delay_ms(2); 
0880:  MOVLW  02
0882:  MOVLB  1
0884:  MOVWF  x0D
0886:  MOVLB  0
0888:  RCALL  011A
....................   AN_0=read_adc();   //lectura canal 0 
088A:  BSF    FC2.1
088C:  BTFSC  FC2.1
088E:  BRA    088C
0890:  MOVFF  FC3,16
0894:  MOVFF  FC4,17
....................   
....................   set_adc_channel(1); //habilitacion canal 1 
0898:  MOVLW  04
089A:  MOVWF  01
089C:  MOVF   FC2,W
089E:  ANDLW  C3
08A0:  IORWF  01,W
08A2:  MOVWF  FC2
....................   delay_ms(2); 
08A4:  MOVLW  02
08A6:  MOVLB  1
08A8:  MOVWF  x0D
08AA:  MOVLB  0
08AC:  RCALL  011A
....................   AN_1=read_adc();   //lectura canal 0 
08AE:  BSF    FC2.1
08B0:  BTFSC  FC2.1
08B2:  BRA    08B0
08B4:  MOVFF  FC3,18
08B8:  MOVFF  FC4,19
....................   ; 
....................   set_adc_channel(2); //habilitacion canal 1 
08BC:  MOVLW  08
08BE:  MOVWF  01
08C0:  MOVF   FC2,W
08C2:  ANDLW  C3
08C4:  IORWF  01,W
08C6:  MOVWF  FC2
....................   delay_ms(2); 
08C8:  MOVLW  02
08CA:  MOVLB  1
08CC:  MOVWF  x0D
08CE:  MOVLB  0
08D0:  RCALL  011A
....................   AN_2=read_adc();   //lectura canal 0 
08D2:  BSF    FC2.1
08D4:  BTFSC  FC2.1
08D6:  BRA    08D4
08D8:  MOVFF  FC3,1A
08DC:  MOVFF  FC4,1B
....................     
....................   set_adc_channel(4); //habilitacion canal 1 
08E0:  MOVLW  10
08E2:  MOVWF  01
08E4:  MOVF   FC2,W
08E6:  ANDLW  C3
08E8:  IORWF  01,W
08EA:  MOVWF  FC2
....................   delay_ms(2); 
08EC:  MOVLW  02
08EE:  MOVLB  1
08F0:  MOVWF  x0D
08F2:  MOVLB  0
08F4:  RCALL  011A
....................   AN_3=read_adc();   //lectura canal 0 
08F6:  BSF    FC2.1
08F8:  BTFSC  FC2.1
08FA:  BRA    08F8
08FC:  MOVFF  FC3,1C
0900:  MOVFF  FC4,1D
0904:  GOTO   14FA (RETURN)
....................   
....................   //delay_ms(100); 
.................... } 
.................... void convertir_ADC0_ADC1_ADC2_ADC3_a_tension() 
.................... {       
....................   AN0_V=2.5*AN_0 /1023.0;    //conversion a tension 
*
0B92:  MOVFF  17,10E
0B96:  MOVFF  16,10D
0B9A:  RCALL  0908
0B9C:  MOVLB  1
0B9E:  CLRF   x10
0BA0:  CLRF   x0F
0BA2:  MOVLW  20
0BA4:  MOVWF  x0E
0BA6:  MOVLW  80
0BA8:  MOVWF  x0D
0BAA:  MOVFF  03,114
0BAE:  MOVFF  02,113
0BB2:  MOVFF  01,112
0BB6:  MOVFF  00,111
0BBA:  MOVLB  0
0BBC:  RCALL  093E
0BBE:  MOVFF  03,110
0BC2:  MOVFF  02,10F
0BC6:  MOVFF  01,10E
0BCA:  MOVFF  00,10D
0BCE:  MOVFF  03,114
0BD2:  MOVFF  02,113
0BD6:  MOVFF  01,112
0BDA:  MOVFF  00,111
0BDE:  MOVLB  1
0BE0:  CLRF   x18
0BE2:  MOVLW  C0
0BE4:  MOVWF  x17
0BE6:  MOVLW  7F
0BE8:  MOVWF  x16
0BEA:  MOVLW  88
0BEC:  MOVWF  x15
0BEE:  MOVLB  0
0BF0:  RCALL  0A34
0BF2:  MOVFF  03,21
0BF6:  MOVFF  02,20
0BFA:  MOVFF  01,1F
0BFE:  MOVFF  00,1E
....................   AN1_V=2.5*AN_1 /1023.0;    //conversion a tension 
0C02:  MOVFF  19,10E
0C06:  MOVFF  18,10D
0C0A:  RCALL  0908
0C0C:  MOVLB  1
0C0E:  CLRF   x10
0C10:  CLRF   x0F
0C12:  MOVLW  20
0C14:  MOVWF  x0E
0C16:  MOVLW  80
0C18:  MOVWF  x0D
0C1A:  MOVFF  03,114
0C1E:  MOVFF  02,113
0C22:  MOVFF  01,112
0C26:  MOVFF  00,111
0C2A:  MOVLB  0
0C2C:  RCALL  093E
0C2E:  MOVFF  03,110
0C32:  MOVFF  02,10F
0C36:  MOVFF  01,10E
0C3A:  MOVFF  00,10D
0C3E:  MOVFF  03,114
0C42:  MOVFF  02,113
0C46:  MOVFF  01,112
0C4A:  MOVFF  00,111
0C4E:  MOVLB  1
0C50:  CLRF   x18
0C52:  MOVLW  C0
0C54:  MOVWF  x17
0C56:  MOVLW  7F
0C58:  MOVWF  x16
0C5A:  MOVLW  88
0C5C:  MOVWF  x15
0C5E:  MOVLB  0
0C60:  RCALL  0A34
0C62:  MOVFF  03,25
0C66:  MOVFF  02,24
0C6A:  MOVFF  01,23
0C6E:  MOVFF  00,22
....................   AN2_V=2.5*AN_2 /1023.0;    //conversion a tension 
0C72:  MOVFF  1B,10E
0C76:  MOVFF  1A,10D
0C7A:  RCALL  0908
0C7C:  MOVLB  1
0C7E:  CLRF   x10
0C80:  CLRF   x0F
0C82:  MOVLW  20
0C84:  MOVWF  x0E
0C86:  MOVLW  80
0C88:  MOVWF  x0D
0C8A:  MOVFF  03,114
0C8E:  MOVFF  02,113
0C92:  MOVFF  01,112
0C96:  MOVFF  00,111
0C9A:  MOVLB  0
0C9C:  RCALL  093E
0C9E:  MOVFF  03,110
0CA2:  MOVFF  02,10F
0CA6:  MOVFF  01,10E
0CAA:  MOVFF  00,10D
0CAE:  MOVFF  03,114
0CB2:  MOVFF  02,113
0CB6:  MOVFF  01,112
0CBA:  MOVFF  00,111
0CBE:  MOVLB  1
0CC0:  CLRF   x18
0CC2:  MOVLW  C0
0CC4:  MOVWF  x17
0CC6:  MOVLW  7F
0CC8:  MOVWF  x16
0CCA:  MOVLW  88
0CCC:  MOVWF  x15
0CCE:  MOVLB  0
0CD0:  RCALL  0A34
0CD2:  MOVFF  03,29
0CD6:  MOVFF  02,28
0CDA:  MOVFF  01,27
0CDE:  MOVFF  00,26
....................   AN3_V=2.5*AN_3 /1023.0;    //conversion a tension 
0CE2:  MOVFF  1D,10E
0CE6:  MOVFF  1C,10D
0CEA:  RCALL  0908
0CEC:  MOVLB  1
0CEE:  CLRF   x10
0CF0:  CLRF   x0F
0CF2:  MOVLW  20
0CF4:  MOVWF  x0E
0CF6:  MOVLW  80
0CF8:  MOVWF  x0D
0CFA:  MOVFF  03,114
0CFE:  MOVFF  02,113
0D02:  MOVFF  01,112
0D06:  MOVFF  00,111
0D0A:  MOVLB  0
0D0C:  RCALL  093E
0D0E:  MOVFF  03,110
0D12:  MOVFF  02,10F
0D16:  MOVFF  01,10E
0D1A:  MOVFF  00,10D
0D1E:  MOVFF  03,114
0D22:  MOVFF  02,113
0D26:  MOVFF  01,112
0D2A:  MOVFF  00,111
0D2E:  MOVLB  1
0D30:  CLRF   x18
0D32:  MOVLW  C0
0D34:  MOVWF  x17
0D36:  MOVLW  7F
0D38:  MOVWF  x16
0D3A:  MOVLW  88
0D3C:  MOVWF  x15
0D3E:  MOVLB  0
0D40:  RCALL  0A34
0D42:  MOVFF  03,2D
0D46:  MOVFF  02,2C
0D4A:  MOVFF  01,2B
0D4E:  MOVFF  00,2A
0D52:  GOTO   14FE (RETURN)
.................... }         
.................... void convertir_ADC0_ADC1_ADC2_ADC3_a_porcentaje()         
.................... { 
....................   AN_0_porcentaje=(int)((AN0_V*100)/0.58); 
*
0D92:  MOVFF  21,110
0D96:  MOVFF  20,10F
0D9A:  MOVFF  1F,10E
0D9E:  MOVFF  1E,10D
0DA2:  MOVLB  1
0DA4:  CLRF   x14
0DA6:  CLRF   x13
0DA8:  MOVLW  48
0DAA:  MOVWF  x12
0DAC:  MOVLW  85
0DAE:  MOVWF  x11
0DB0:  MOVLB  0
0DB2:  RCALL  093E
0DB4:  MOVFF  03,110
0DB8:  MOVFF  02,10F
0DBC:  MOVFF  01,10E
0DC0:  MOVFF  00,10D
0DC4:  MOVFF  03,114
0DC8:  MOVFF  02,113
0DCC:  MOVFF  01,112
0DD0:  MOVFF  00,111
0DD4:  MOVLW  E1
0DD6:  MOVLB  1
0DD8:  MOVWF  x18
0DDA:  MOVLW  7A
0DDC:  MOVWF  x17
0DDE:  MOVLW  14
0DE0:  MOVWF  x16
0DE2:  MOVLW  7E
0DE4:  MOVWF  x15
0DE6:  MOVLB  0
0DE8:  RCALL  0A34
0DEA:  MOVFF  03,110
0DEE:  MOVFF  02,10F
0DF2:  MOVFF  01,10E
0DF6:  MOVFF  00,10D
0DFA:  RCALL  0D56
0DFC:  MOVFF  01,2E
....................   AN_1_porcentaje=(int)((AN1_V*100)/0.58); 
0E00:  MOVFF  25,110
0E04:  MOVFF  24,10F
0E08:  MOVFF  23,10E
0E0C:  MOVFF  22,10D
0E10:  MOVLB  1
0E12:  CLRF   x14
0E14:  CLRF   x13
0E16:  MOVLW  48
0E18:  MOVWF  x12
0E1A:  MOVLW  85
0E1C:  MOVWF  x11
0E1E:  MOVLB  0
0E20:  RCALL  093E
0E22:  MOVFF  03,110
0E26:  MOVFF  02,10F
0E2A:  MOVFF  01,10E
0E2E:  MOVFF  00,10D
0E32:  MOVFF  03,114
0E36:  MOVFF  02,113
0E3A:  MOVFF  01,112
0E3E:  MOVFF  00,111
0E42:  MOVLW  E1
0E44:  MOVLB  1
0E46:  MOVWF  x18
0E48:  MOVLW  7A
0E4A:  MOVWF  x17
0E4C:  MOVLW  14
0E4E:  MOVWF  x16
0E50:  MOVLW  7E
0E52:  MOVWF  x15
0E54:  MOVLB  0
0E56:  RCALL  0A34
0E58:  MOVFF  03,110
0E5C:  MOVFF  02,10F
0E60:  MOVFF  01,10E
0E64:  MOVFF  00,10D
0E68:  RCALL  0D56
0E6A:  MOVFF  01,2F
....................   AN_2_porcentaje=(int)((AN2_V*100)/0.58); 
0E6E:  MOVFF  29,110
0E72:  MOVFF  28,10F
0E76:  MOVFF  27,10E
0E7A:  MOVFF  26,10D
0E7E:  MOVLB  1
0E80:  CLRF   x14
0E82:  CLRF   x13
0E84:  MOVLW  48
0E86:  MOVWF  x12
0E88:  MOVLW  85
0E8A:  MOVWF  x11
0E8C:  MOVLB  0
0E8E:  RCALL  093E
0E90:  MOVFF  03,110
0E94:  MOVFF  02,10F
0E98:  MOVFF  01,10E
0E9C:  MOVFF  00,10D
0EA0:  MOVFF  03,114
0EA4:  MOVFF  02,113
0EA8:  MOVFF  01,112
0EAC:  MOVFF  00,111
0EB0:  MOVLW  E1
0EB2:  MOVLB  1
0EB4:  MOVWF  x18
0EB6:  MOVLW  7A
0EB8:  MOVWF  x17
0EBA:  MOVLW  14
0EBC:  MOVWF  x16
0EBE:  MOVLW  7E
0EC0:  MOVWF  x15
0EC2:  MOVLB  0
0EC4:  RCALL  0A34
0EC6:  MOVFF  03,110
0ECA:  MOVFF  02,10F
0ECE:  MOVFF  01,10E
0ED2:  MOVFF  00,10D
0ED6:  RCALL  0D56
0ED8:  MOVFF  01,30
....................   AN_3_porcentaje=(int)((AN3_V*100)/0.58); 
0EDC:  MOVFF  2D,110
0EE0:  MOVFF  2C,10F
0EE4:  MOVFF  2B,10E
0EE8:  MOVFF  2A,10D
0EEC:  MOVLB  1
0EEE:  CLRF   x14
0EF0:  CLRF   x13
0EF2:  MOVLW  48
0EF4:  MOVWF  x12
0EF6:  MOVLW  85
0EF8:  MOVWF  x11
0EFA:  MOVLB  0
0EFC:  RCALL  093E
0EFE:  MOVFF  03,110
0F02:  MOVFF  02,10F
0F06:  MOVFF  01,10E
0F0A:  MOVFF  00,10D
0F0E:  MOVFF  03,114
0F12:  MOVFF  02,113
0F16:  MOVFF  01,112
0F1A:  MOVFF  00,111
0F1E:  MOVLW  E1
0F20:  MOVLB  1
0F22:  MOVWF  x18
0F24:  MOVLW  7A
0F26:  MOVWF  x17
0F28:  MOVLW  14
0F2A:  MOVWF  x16
0F2C:  MOVLW  7E
0F2E:  MOVWF  x15
0F30:  MOVLB  0
0F32:  RCALL  0A34
0F34:  MOVFF  03,110
0F38:  MOVFF  02,10F
0F3C:  MOVFF  01,10E
0F40:  MOVFF  00,10D
0F44:  RCALL  0D56
0F46:  MOVFF  01,31
0F4A:  GOTO   1500 (RETURN)
.................... }   //512      
....................  
.................... #use standard_io (a) 
.................... #use standard_io (b)  
.................... #use standard_io (c) 
.................... #use standard_io (d)  
.................... #use standard_io (e) 
.................... //#define LCD_ENABLE_PIN  PIN_D7 
.................... //#define LCD_RS_PIN      PIN_D6                                     
.................... //#define LCD_RW_PIN      PIN_D5                                    
.................... //#define LCD_DATA4       PIN_D4                                    
.................... //#define LCD_DATA5       PIN_D2                                     
.................... //#define LCD_DATA6       PIN_D1                                    
.................... //#define LCD_DATA7       PIN_D0  
.................... //#include <LCD_nuevo.C> 
.................... #define char_int(c) ((int)((c)-48))  
.................... #byte UCON=0xF6D 
.................... #bit USBEN=UCON.3  
.................... #byte UCFG = 0xF6F  
.................... #bit UTRDIS = UCFG.3  
.................... #INCLUDE <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
1032:  MOVFF  10E,112
1036:  MOVFF  10D,111
103A:  MOVFF  112,03
103E:  MOVLB  1
1040:  MOVFF  111,FE9
1044:  MOVFF  112,FEA
1048:  MOVF   FEF,F
104A:  BZ    1058
104C:  INCF   x11,F
104E:  BTFSC  FD8.2
1050:  INCF   x12,F
1052:  MOVLB  0
1054:  BRA    103A
1056:  MOVLB  1
....................    while(*s2 != '\0') 
1058:  MOVFF  110,03
105C:  MOVFF  10F,FE9
1060:  MOVFF  110,FEA
1064:  MOVF   FEF,F
1066:  BZ    108E
....................    { 
....................       *s = *s2; 
1068:  MOVFF  10F,FE9
106C:  MOVFF  110,FEA
1070:  MOVFF  FEF,115
1074:  MOVFF  112,FEA
1078:  MOVFF  111,FE9
107C:  MOVFF  115,FEF
....................       ++s; 
1080:  INCF   x11,F
1082:  BTFSC  FD8.2
1084:  INCF   x12,F
....................       ++s2; 
1086:  INCF   x0F,F
1088:  BTFSC  FD8.2
108A:  INCF   x10,F
108C:  BRA    1058
....................    } 
....................  
....................    *s = '\0'; 
108E:  MOVFF  111,FE9
1092:  MOVFF  112,FEA
1096:  CLRF   FEF
....................    return(s1); 
1098:  MOVFF  10D,01
109C:  MOVFF  10E,02
10A0:  MOVLB  0
10A2:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
01F6:  MOVLB  1
01F8:  CLRF   x15
....................    sign = 0; 
01FA:  CLRF   x13
....................    base = 10; 
01FC:  MOVLW  0A
01FE:  MOVWF  x14
....................    result = 0; 
0200:  CLRF   x12
0202:  CLRF   x11
0204:  CLRF   x10
0206:  CLRF   x0F
....................  
....................    if (!s) 
0208:  MOVF   x0D,W
020A:  IORWF  x0E,W
020C:  BNZ   0218
....................       return 0; 
020E:  CLRF   00
0210:  CLRF   01
0212:  CLRF   02
0214:  CLRF   03
0216:  BRA    0496
....................    c = s[index++]; 
0218:  MOVF   x15,W
021A:  INCF   x15,F
021C:  CLRF   03
021E:  ADDWF  x0D,W
0220:  MOVWF  FE9
0222:  MOVF   x0E,W
0224:  ADDWFC 03,W
0226:  MOVWF  FEA
0228:  MOVFF  FEF,116
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
022C:  MOVF   x16,W
022E:  SUBLW  2D
0230:  BNZ   024C
....................    { 
....................       sign = 1;         // Set the sign to negative 
0232:  MOVLW  01
0234:  MOVWF  x13
....................       c = s[index++]; 
0236:  MOVF   x15,W
0238:  INCF   x15,F
023A:  CLRF   03
023C:  ADDWF  x0D,W
023E:  MOVWF  FE9
0240:  MOVF   x0E,W
0242:  ADDWFC 03,W
0244:  MOVWF  FEA
0246:  MOVFF  FEF,116
....................    } 
024A:  BRA    0266
....................    else if (c == '+') 
024C:  MOVF   x16,W
024E:  SUBLW  2B
0250:  BNZ   0266
....................    { 
....................       c = s[index++]; 
0252:  MOVF   x15,W
0254:  INCF   x15,F
0256:  CLRF   03
0258:  ADDWF  x0D,W
025A:  MOVWF  FE9
025C:  MOVF   x0E,W
025E:  ADDWFC 03,W
0260:  MOVWF  FEA
0262:  MOVFF  FEF,116
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0266:  MOVF   x16,W
0268:  SUBLW  2F
026A:  BTFSC  FD8.0
026C:  BRA    0466
026E:  MOVF   x16,W
0270:  SUBLW  39
0272:  BTFSS  FD8.0
0274:  BRA    0466
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0276:  MOVF   x16,W
0278:  SUBLW  30
027A:  BNZ   02BE
027C:  CLRF   03
027E:  MOVF   x15,W
0280:  ADDWF  x0D,W
0282:  MOVWF  FE9
0284:  MOVF   x0E,W
0286:  ADDWFC 03,W
0288:  MOVWF  FEA
028A:  MOVF   FEF,W
028C:  SUBLW  78
028E:  BZ    02A4
0290:  CLRF   03
0292:  MOVF   x15,W
0294:  ADDWF  x0D,W
0296:  MOVWF  FE9
0298:  MOVF   x0E,W
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVF   FEF,W
02A0:  SUBLW  58
02A2:  BNZ   02BE
....................       { 
....................          base = 16; 
02A4:  MOVLW  10
02A6:  MOVWF  x14
....................          index++; 
02A8:  INCF   x15,F
....................          c = s[index++]; 
02AA:  MOVF   x15,W
02AC:  INCF   x15,F
02AE:  CLRF   03
02B0:  ADDWF  x0D,W
02B2:  MOVWF  FE9
02B4:  MOVF   x0E,W
02B6:  ADDWFC 03,W
02B8:  MOVWF  FEA
02BA:  MOVFF  FEF,116
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02BE:  MOVF   x14,W
02C0:  SUBLW  0A
02C2:  BNZ   034C
....................       { 
....................          while (c >= '0' && c <= '9') { 
02C4:  MOVF   x16,W
02C6:  SUBLW  2F
02C8:  BC    034A
02CA:  MOVF   x16,W
02CC:  SUBLW  39
02CE:  BNC   034A
....................             result = (result << 1) + (result << 3);  // result *= 10; 
02D0:  BCF    FD8.0
02D2:  RLCF   x0F,W
02D4:  MOVWF  x18
02D6:  RLCF   x10,W
02D8:  MOVWF  x19
02DA:  RLCF   x11,W
02DC:  MOVWF  x1A
02DE:  RLCF   x12,W
02E0:  MOVWF  x1B
02E2:  RLCF   x0F,W
02E4:  MOVWF  00
02E6:  RLCF   x10,W
02E8:  MOVWF  01
02EA:  RLCF   x11,W
02EC:  MOVWF  02
02EE:  RLCF   x12,W
02F0:  MOVWF  03
02F2:  RLCF   00,F
02F4:  RLCF   01,F
02F6:  RLCF   02,F
02F8:  RLCF   03,F
02FA:  RLCF   00,F
02FC:  RLCF   01,F
02FE:  RLCF   02,F
0300:  RLCF   03,F
0302:  MOVLW  F8
0304:  ANDWF  00,F
0306:  MOVF   x18,W
0308:  ADDWF  00,F
030A:  MOVF   x19,W
030C:  ADDWFC 01,F
030E:  MOVF   x1A,W
0310:  ADDWFC 02,F
0312:  MOVF   x1B,W
0314:  ADDWFC 03,F
0316:  MOVFF  03,112
031A:  MOVFF  02,111
031E:  MOVFF  01,110
0322:  MOVFF  00,10F
....................             result += (c - '0'); 
0326:  MOVLW  30
0328:  SUBWF  x16,W
032A:  ADDWF  x0F,F
032C:  MOVLW  00
032E:  ADDWFC x10,F
0330:  ADDWFC x11,F
0332:  ADDWFC x12,F
....................             c = s[index++]; 
0334:  MOVF   x15,W
0336:  INCF   x15,F
0338:  CLRF   03
033A:  ADDWF  x0D,W
033C:  MOVWF  FE9
033E:  MOVF   x0E,W
0340:  ADDWFC 03,W
0342:  MOVWF  FEA
0344:  MOVFF  FEF,116
0348:  BRA    02C4
....................          } 
....................       } 
034A:  BRA    0466
....................       else if (base == 16)    // The number is a hexa number 
034C:  MOVF   x14,W
034E:  SUBLW  10
0350:  BTFSS  FD8.2
0352:  BRA    0466
....................       { 
....................          c = toupper(c); 
0354:  MOVF   x16,W
0356:  SUBLW  60
0358:  BC    0366
035A:  MOVF   x16,W
035C:  SUBLW  7A
035E:  BNC   0366
0360:  MOVF   x16,W
0362:  ANDLW  DF
0364:  BRA    0368
0366:  MOVF   x16,W
0368:  MOVWF  x16
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
036A:  MOVF   x16,W
036C:  SUBLW  2F
036E:  BC    0376
0370:  MOVF   x16,W
0372:  SUBLW  39
0374:  BC    0384
0376:  MOVF   x16,W
0378:  SUBLW  40
037A:  BTFSC  FD8.0
037C:  BRA    0466
037E:  MOVF   x16,W
0380:  SUBLW  46
0382:  BNC   0466
....................          { 
....................             if (c >= '0' && c <= '9') 
0384:  MOVF   x16,W
0386:  SUBLW  2F
0388:  BC    03E6
038A:  MOVF   x16,W
038C:  SUBLW  39
038E:  BNC   03E6
....................                result = (result << 4) + (c - '0'); 
0390:  RLCF   x0F,W
0392:  MOVWF  x18
0394:  RLCF   x10,W
0396:  MOVWF  x19
0398:  RLCF   x11,W
039A:  MOVWF  x1A
039C:  RLCF   x12,W
039E:  MOVWF  x1B
03A0:  RLCF   x18,F
03A2:  RLCF   x19,F
03A4:  RLCF   x1A,F
03A6:  RLCF   x1B,F
03A8:  RLCF   x18,F
03AA:  RLCF   x19,F
03AC:  RLCF   x1A,F
03AE:  RLCF   x1B,F
03B0:  RLCF   x18,F
03B2:  RLCF   x19,F
03B4:  RLCF   x1A,F
03B6:  RLCF   x1B,F
03B8:  MOVLW  F0
03BA:  ANDWF  x18,F
03BC:  MOVLW  30
03BE:  SUBWF  x16,W
03C0:  ADDWF  x18,W
03C2:  MOVWF  00
03C4:  MOVLW  00
03C6:  ADDWFC x19,W
03C8:  MOVWF  01
03CA:  MOVLW  00
03CC:  ADDWFC x1A,W
03CE:  MOVWF  02
03D0:  MOVLW  00
03D2:  ADDWFC x1B,W
03D4:  MOVWF  03
03D6:  MOVWF  x12
03D8:  MOVFF  02,111
03DC:  MOVFF  01,110
03E0:  MOVFF  00,10F
03E4:  BRA    043A
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
03E6:  RLCF   x0F,W
03E8:  MOVWF  x18
03EA:  RLCF   x10,W
03EC:  MOVWF  x19
03EE:  RLCF   x11,W
03F0:  MOVWF  x1A
03F2:  RLCF   x12,W
03F4:  MOVWF  x1B
03F6:  RLCF   x18,F
03F8:  RLCF   x19,F
03FA:  RLCF   x1A,F
03FC:  RLCF   x1B,F
03FE:  RLCF   x18,F
0400:  RLCF   x19,F
0402:  RLCF   x1A,F
0404:  RLCF   x1B,F
0406:  RLCF   x18,F
0408:  RLCF   x19,F
040A:  RLCF   x1A,F
040C:  RLCF   x1B,F
040E:  MOVLW  F0
0410:  ANDWF  x18,F
0412:  MOVLW  41
0414:  SUBWF  x16,W
0416:  ADDLW  0A
0418:  ADDWF  x18,W
041A:  MOVWF  00
041C:  MOVLW  00
041E:  ADDWFC x19,W
0420:  MOVWF  01
0422:  MOVLW  00
0424:  ADDWFC x1A,W
0426:  MOVWF  02
0428:  MOVLW  00
042A:  ADDWFC x1B,W
042C:  MOVWF  x12
042E:  MOVFF  02,111
0432:  MOVFF  01,110
0436:  MOVFF  00,10F
....................  
....................             c = s[index++];c = toupper(c); 
043A:  MOVF   x15,W
043C:  INCF   x15,F
043E:  CLRF   03
0440:  ADDWF  x0D,W
0442:  MOVWF  FE9
0444:  MOVF   x0E,W
0446:  ADDWFC 03,W
0448:  MOVWF  FEA
044A:  MOVFF  FEF,116
044E:  MOVF   x16,W
0450:  SUBLW  60
0452:  BC    0460
0454:  MOVF   x16,W
0456:  SUBLW  7A
0458:  BNC   0460
045A:  MOVF   x16,W
045C:  ANDLW  DF
045E:  BRA    0462
0460:  MOVF   x16,W
0462:  MOVWF  x16
0464:  BRA    036A
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0466:  MOVF   x14,W
0468:  SUBLW  0A
046A:  BNZ   0486
046C:  DECFSZ x13,W
046E:  BRA    0486
....................       result = -result; 
0470:  COMF   x0F,F
0472:  COMF   x10,F
0474:  COMF   x11,F
0476:  COMF   x12,F
0478:  INCF   x0F,F
047A:  BTFSC  FD8.2
047C:  INCF   x10,F
047E:  BTFSC  FD8.2
0480:  INCF   x11,F
0482:  BTFSC  FD8.2
0484:  INCF   x12,F
....................  
....................    return(result); 
0486:  MOVFF  10F,00
048A:  MOVFF  110,01
048E:  MOVFF  111,02
0492:  MOVFF  112,03
0496:  MOVLB  0
0498:  RETURN 0
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use rtos(timer = 0, minor_cycle =5ms) 
.................... int16 valor_humedad[4]; 
.................... int16 hum_i_1,hum_i_2,hum_i_3,hum_i_4; 
.................... int16 hum_f_1,hum_f_2,hum_f_3,hum_f_4; 
.................... int16 item; 
.................... int16 n_menus; 
.................... int16 i_rx=0; 
.................... int16 dato_completo=0; 
.................... int regando_1=0,regando_2=0,regando_3=0,regando_4=0,regando_t=0; 
.................... int sube_1=0,sube_2=0,sube_3=0,sube_4=0; 
.................... int baja_1=0,baja_2=0,baja_3=0,baja_4=0; 
.................... char  dato_tx[30]; 
.................... char  dato_rx[30]; 
.................... char  cadena[6]; 
.................... char  dato_aux[5],dato_aux2[5]; 
.................... int numero=0,fin_pal=0,dat_comp=0,j=0,s=0,m=0; 
.................... const int STATE_INI    = 1; 
.................... const int STATE_SEND   = 2; 
.................... const int STATE_ACTIVO = 3; 
.................... int estado_siguiente=1; 
.................... const int STATE_INICIAL           = 0; 
.................... const int STATE_ACT               = 1; 
.................... const int STATE_MANUAL            = 2; 
.................... const int STATE_TIEMPO            = 3; 
.................... const int STATE_HUMEDAD           = 4; 
.................... const int STATE_ACTIVAR_VALVULA   = 5; 
.................... const int STATE_DESACTIVAR_VALVULA = 6; 
.................... int estado_siguiente_riego=0; 
.................... int hora=0, minutos=0; 
.................... int minima=0, maxima=0, hora_inicio=0, minutos_inicio=0; 
.................... int hora_fin=0, minutos_fin=0; 
.................... int salida[4]; 
.................... int manual=0; 
.................... int16 comando_rx=10; 
.................... int16 comando_tx=1; 
.................... int16 estado_valvula_1_placa_1=0; 
.................... int16 estado_valvula_2_placa_1=0; 
.................... int16 humedad_ciclo_uno=0; 
.................... int16 humedad_ciclo_dos=0; 
.................... int tipo_riego=0; 
.................... int tipo_riego_anterior =0; 
.................... int minima_guardada=0; 
.................... int maxima_guardada=0; 
.................... int entro_manual=0; 
.................... int regando_1_anterior=0; 
.................... int regando_2_anterior=0; 
.................... int regando_t_anterior=0; 
.................... #int_rda 
.................... STATE_STORE() 
.................... { 
....................  dato_rx[i_rx]=getc(); 
*
00D8:  MOVLW  84
00DA:  ADDWF  55,W
00DC:  MOVWF  FE9
00DE:  MOVLW  00
00E0:  ADDWFC 56,W
00E2:  MOVWF  FEA
00E4:  BTFSS  F9E.5
00E6:  BRA    00E4
00E8:  MOVFF  FAE,FEF
....................  if (dato_rx[i_rx]=='&') 
00EC:  MOVLW  84
00EE:  ADDWF  55,W
00F0:  MOVWF  FE9
00F2:  MOVLW  00
00F4:  ADDWFC 56,W
00F6:  MOVWF  FEA
00F8:  MOVF   FEF,W
00FA:  SUBLW  26
00FC:  BNZ   010A
....................  { 
....................   dato_completo=1; 
00FE:  CLRF   58
0100:  MOVLW  01
0102:  MOVWF  57
....................   i_rx=0; 
0104:  CLRF   56
0106:  CLRF   55
....................  } 
0108:  BRA    0114
....................  else 
....................    { 
....................     dato_completo=0; 
010A:  CLRF   58
010C:  CLRF   57
....................     i_rx++; 
010E:  INCF   55,F
0110:  BTFSC  FD8.2
0112:  INCF   56,F
....................    } 
0114:  BCF    F9E.5
0116:  GOTO   0054
.................... } 
....................  
.................... int lee_pulsador(byte pin) 
.................... { 
....................  if (input(pin)==1) return(1); else return (0); 
.................... } 
.................... void activar_rele(byte pin) 
.................... { 
....................  output_high(pin); 
*
174A:  MOVFF  10D,10E
174E:  MOVLW  01
1750:  MOVLB  1
1752:  MOVWF  x0F
1754:  MOVLW  0F
1756:  MOVWF  x11
1758:  MOVLW  89
175A:  MOVWF  x10
175C:  MOVLB  0
175E:  RCALL  1708
1760:  MOVFF  10D,10E
1764:  MOVLB  1
1766:  CLRF   x0F
1768:  MOVLW  0F
176A:  MOVWF  x11
176C:  MOVLW  92
176E:  MOVWF  x10
1770:  MOVLB  0
1772:  RCALL  1708
1774:  RETURN 0
.................... } 
.................... void desactivar_rele(byte pin) 
.................... { 
....................  output_low(pin); 
1776:  MOVFF  10D,10E
177A:  MOVLB  1
177C:  CLRF   x0F
177E:  MOVLW  0F
1780:  MOVWF  x11
1782:  MOVLW  89
1784:  MOVWF  x10
1786:  MOVLB  0
1788:  RCALL  1708
178A:  MOVFF  10D,10E
178E:  MOVLB  1
1790:  CLRF   x0F
1792:  MOVLW  0F
1794:  MOVWF  x11
1796:  MOVLW  92
1798:  MOVWF  x10
179A:  MOVLB  0
179C:  RCALL  1708
179E:  RETURN 0
.................... } 
.................... void encender_led(byte pin) 
.................... { 
....................  output_high(pin); 
.................... } 
.................... void apagar_led(byte pin) 
.................... { 
....................  output_low(pin); 
.................... } 
.................... void envio_dato() 
*
01AA:  MOVLW  28
01AC:  MOVLB  1
01AE:  MOVWF  x0E
.................... { 
....................  int i_tx,fin_dto=40; 
....................  for(i_tx=0;i_tx<=fin_dto;i_tx++) 
01B0:  CLRF   x0D
01B2:  MOVF   x0D,W
01B4:  SUBWF  x0E,W
01B6:  BNC   01F0
....................  { 
....................   putc(dato_tx[i_tx]); 
01B8:  CLRF   03
01BA:  MOVF   x0D,W
01BC:  ADDLW  66
01BE:  MOVWF  FE9
01C0:  MOVLW  00
01C2:  ADDWFC 03,W
01C4:  MOVWF  FEA
01C6:  MOVFF  FEF,10F
01CA:  MOVFF  10F,110
01CE:  MOVLB  0
01D0:  BRA    0180
....................   if (dato_tx[i_tx]=='&') fin_dto=i_tx; 
01D2:  CLRF   03
01D4:  MOVLB  1
01D6:  MOVF   x0D,W
01D8:  ADDLW  66
01DA:  MOVWF  FE9
01DC:  MOVLW  00
01DE:  ADDWFC 03,W
01E0:  MOVWF  FEA
01E2:  MOVF   FEF,W
01E4:  SUBLW  26
01E6:  BTFSC  FD8.2
01E8:  MOVFF  10D,10E
01EC:  INCF   x0D,F
01EE:  BRA    01B2
....................  } 
01F0:  MOVLB  0
01F2:  GOTO   14AE (RETURN)
.................... } 
.................... void armar_trama() 
.................... { 
....................  dato_tx[0]='0'; 
*
114E:  MOVLW  30
1150:  MOVWF  x66
....................  strcpy(dato_tx,"00000001"); 
1152:  CLRF   FEA
1154:  MOVLW  66
1156:  MOVWF  FE9
1158:  MOVFF  FF2,10D
115C:  BCF    FF2.7
115E:  MOVLW  00
1160:  CALL   0096
1164:  TBLRD*-
1166:  TBLRD*+
1168:  MOVF   FF5,W
116A:  MOVWF  FEE
116C:  IORLW  00
116E:  BNZ   1166
1170:  MOVLB  1
1172:  BTFSC  x0D.7
1174:  BSF    FF2.7
....................  sprintf(cadena,"%lu",comando_tx); 
1176:  MOVLB  0
1178:  CLRF   xDC
117A:  MOVLW  A2
117C:  MOVWF  xDB
117E:  MOVLW  10
1180:  MOVWF  FE9
1182:  MOVFF  CA,10E
1186:  MOVFF  C9,10D
118A:  RCALL  0F6E
....................  strcat(dato_tx,cadena); 
118C:  MOVLB  1
118E:  CLRF   x0E
1190:  MOVLW  66
1192:  MOVWF  x0D
1194:  CLRF   x10
1196:  MOVLW  A2
1198:  MOVWF  x0F
119A:  MOVLB  0
119C:  RCALL  1032
....................  sprintf(cadena,"+"); 
119E:  CLRF   xDC
11A0:  MOVLW  A2
11A2:  MOVWF  xDB
11A4:  MOVLW  2B
11A6:  MOVLB  1
11A8:  MOVWF  x16
11AA:  MOVLB  0
11AC:  RCALL  0F4E
....................  strcat(dato_tx,cadena); 
11AE:  MOVLB  1
11B0:  CLRF   x0E
11B2:  MOVLW  66
11B4:  MOVWF  x0D
11B6:  CLRF   x10
11B8:  MOVLW  A2
11BA:  MOVWF  x0F
11BC:  MOVLB  0
11BE:  RCALL  1032
....................  if (comando_tx==1)  
11C0:  DECFSZ xC9,W
11C2:  BRA    12EA
11C4:  MOVF   xCA,F
11C6:  BTFSS  FD8.2
11C8:  BRA    12EA
....................  { 
....................   sprintf(cadena,"%lu",valor_humedad[0]); 
11CA:  CLRF   xDC
11CC:  MOVLW  A2
11CE:  MOVWF  xDB
11D0:  MOVLW  10
11D2:  MOVWF  FE9
11D4:  MOVFF  3A,10E
11D8:  MOVFF  39,10D
11DC:  RCALL  0F6E
....................   strcat(dato_tx,cadena); 
11DE:  MOVLB  1
11E0:  CLRF   x0E
11E2:  MOVLW  66
11E4:  MOVWF  x0D
11E6:  CLRF   x10
11E8:  MOVLW  A2
11EA:  MOVWF  x0F
11EC:  MOVLB  0
11EE:  RCALL  1032
....................   sprintf(cadena,"+"); 
11F0:  CLRF   xDC
11F2:  MOVLW  A2
11F4:  MOVWF  xDB
11F6:  MOVLW  2B
11F8:  MOVLB  1
11FA:  MOVWF  x16
11FC:  MOVLB  0
11FE:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
1200:  MOVLB  1
1202:  CLRF   x0E
1204:  MOVLW  66
1206:  MOVWF  x0D
1208:  CLRF   x10
120A:  MOVLW  A2
120C:  MOVWF  x0F
120E:  MOVLB  0
1210:  RCALL  1032
....................   sprintf(cadena,"%lu",valor_humedad[1]); 
1212:  CLRF   xDC
1214:  MOVLW  A2
1216:  MOVWF  xDB
1218:  MOVLW  10
121A:  MOVWF  FE9
121C:  MOVFF  3C,10E
1220:  MOVFF  3B,10D
1224:  RCALL  0F6E
....................   strcat(dato_tx,cadena); 
1226:  MOVLB  1
1228:  CLRF   x0E
122A:  MOVLW  66
122C:  MOVWF  x0D
122E:  CLRF   x10
1230:  MOVLW  A2
1232:  MOVWF  x0F
1234:  MOVLB  0
1236:  RCALL  1032
....................   sprintf(cadena,"+"); 
1238:  CLRF   xDC
123A:  MOVLW  A2
123C:  MOVWF  xDB
123E:  MOVLW  2B
1240:  MOVLB  1
1242:  MOVWF  x16
1244:  MOVLB  0
1246:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
1248:  MOVLB  1
124A:  CLRF   x0E
124C:  MOVLW  66
124E:  MOVWF  x0D
1250:  CLRF   x10
1252:  MOVLW  A2
1254:  MOVWF  x0F
1256:  MOVLB  0
1258:  RCALL  1032
....................   sprintf(cadena,"%lu",valor_humedad[2]); 
125A:  CLRF   xDC
125C:  MOVLW  A2
125E:  MOVWF  xDB
1260:  MOVLW  10
1262:  MOVWF  FE9
1264:  MOVFF  3E,10E
1268:  MOVFF  3D,10D
126C:  RCALL  0F6E
....................   strcat(dato_tx,cadena); 
126E:  MOVLB  1
1270:  CLRF   x0E
1272:  MOVLW  66
1274:  MOVWF  x0D
1276:  CLRF   x10
1278:  MOVLW  A2
127A:  MOVWF  x0F
127C:  MOVLB  0
127E:  RCALL  1032
....................   sprintf(cadena,"+"); 
1280:  CLRF   xDC
1282:  MOVLW  A2
1284:  MOVWF  xDB
1286:  MOVLW  2B
1288:  MOVLB  1
128A:  MOVWF  x16
128C:  MOVLB  0
128E:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
1290:  MOVLB  1
1292:  CLRF   x0E
1294:  MOVLW  66
1296:  MOVWF  x0D
1298:  CLRF   x10
129A:  MOVLW  A2
129C:  MOVWF  x0F
129E:  MOVLB  0
12A0:  RCALL  1032
....................   sprintf(cadena,"%lu",valor_humedad[3]); 
12A2:  CLRF   xDC
12A4:  MOVLW  A2
12A6:  MOVWF  xDB
12A8:  MOVLW  10
12AA:  MOVWF  FE9
12AC:  MOVFF  40,10E
12B0:  MOVFF  3F,10D
12B4:  RCALL  0F6E
....................   strcat(dato_tx,cadena); 
12B6:  MOVLB  1
12B8:  CLRF   x0E
12BA:  MOVLW  66
12BC:  MOVWF  x0D
12BE:  CLRF   x10
12C0:  MOVLW  A2
12C2:  MOVWF  x0F
12C4:  MOVLB  0
12C6:  RCALL  1032
....................   sprintf(cadena,"&"); 
12C8:  CLRF   xDC
12CA:  MOVLW  A2
12CC:  MOVWF  xDB
12CE:  MOVLW  26
12D0:  MOVLB  1
12D2:  MOVWF  x16
12D4:  MOVLB  0
12D6:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
12D8:  MOVLB  1
12DA:  CLRF   x0E
12DC:  MOVLW  66
12DE:  MOVWF  x0D
12E0:  CLRF   x10
12E2:  MOVLW  A2
12E4:  MOVWF  x0F
12E6:  MOVLB  0
12E8:  RCALL  1032
....................  } 
....................  if (comando_tx==2)  
12EA:  MOVF   xC9,W
12EC:  SUBLW  02
12EE:  BNZ   13CE
12F0:  MOVF   xCA,F
12F2:  BNZ   13CE
....................  { 
....................   sprintf(cadena,"%lu",estado_valvula_1_placa_1); 
12F4:  CLRF   xDC
12F6:  MOVLW  A2
12F8:  MOVWF  xDB
12FA:  MOVLW  10
12FC:  MOVWF  FE9
12FE:  MOVFF  CC,10E
1302:  MOVFF  CB,10D
1306:  RCALL  0F6E
....................   strcat(dato_tx,cadena); 
1308:  MOVLB  1
130A:  CLRF   x0E
130C:  MOVLW  66
130E:  MOVWF  x0D
1310:  CLRF   x10
1312:  MOVLW  A2
1314:  MOVWF  x0F
1316:  MOVLB  0
1318:  RCALL  1032
....................   sprintf(cadena,"+"); 
131A:  CLRF   xDC
131C:  MOVLW  A2
131E:  MOVWF  xDB
1320:  MOVLW  2B
1322:  MOVLB  1
1324:  MOVWF  x16
1326:  MOVLB  0
1328:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
132A:  MOVLB  1
132C:  CLRF   x0E
132E:  MOVLW  66
1330:  MOVWF  x0D
1332:  CLRF   x10
1334:  MOVLW  A2
1336:  MOVWF  x0F
1338:  MOVLB  0
133A:  RCALL  1032
....................   sprintf(cadena,"%lu",estado_valvula_2_placa_1); 
133C:  CLRF   xDC
133E:  MOVLW  A2
1340:  MOVWF  xDB
1342:  MOVLW  10
1344:  MOVWF  FE9
1346:  MOVFF  CE,10E
134A:  MOVFF  CD,10D
134E:  RCALL  0F6E
....................   strcat(dato_tx,cadena); 
1350:  MOVLB  1
1352:  CLRF   x0E
1354:  MOVLW  66
1356:  MOVWF  x0D
1358:  CLRF   x10
135A:  MOVLW  A2
135C:  MOVWF  x0F
135E:  MOVLB  0
1360:  RCALL  1032
....................   sprintf(cadena,"+"); 
1362:  CLRF   xDC
1364:  MOVLW  A2
1366:  MOVWF  xDB
1368:  MOVLW  2B
136A:  MOVLB  1
136C:  MOVWF  x16
136E:  MOVLB  0
1370:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
1372:  MOVLB  1
1374:  CLRF   x0E
1376:  MOVLW  66
1378:  MOVWF  x0D
137A:  CLRF   x10
137C:  MOVLW  A2
137E:  MOVWF  x0F
1380:  MOVLB  0
1382:  RCALL  1032
....................   sprintf(cadena,"%u",tipo_riego); 
1384:  CLRF   xDC
1386:  MOVLW  A2
1388:  MOVWF  xDB
138A:  MOVFF  D3,10D
138E:  MOVLW  1B
1390:  MOVLB  1
1392:  MOVWF  x0E
1394:  MOVLB  0
1396:  BRA    10D0
....................   strcat(dato_tx,cadena); 
1398:  MOVLB  1
139A:  CLRF   x0E
139C:  MOVLW  66
139E:  MOVWF  x0D
13A0:  CLRF   x10
13A2:  MOVLW  A2
13A4:  MOVWF  x0F
13A6:  MOVLB  0
13A8:  RCALL  1032
....................   sprintf(cadena,"&"); 
13AA:  CLRF   xDC
13AC:  MOVLW  A2
13AE:  MOVWF  xDB
13B0:  MOVLW  26
13B2:  MOVLB  1
13B4:  MOVWF  x16
13B6:  MOVLB  0
13B8:  RCALL  0F4E
....................   strcat(dato_tx,cadena); 
13BA:  MOVLB  1
13BC:  CLRF   x0E
13BE:  MOVLW  66
13C0:  MOVWF  x0D
13C2:  CLRF   x10
13C4:  MOVLW  A2
13C6:  MOVWF  x0F
13C8:  MOVLB  0
13CA:  RCALL  1032
....................   tipo_riego_anterior=0; 
13CC:  CLRF   xD4
....................  } 
13CE:  GOTO   1552 (RETURN)
.................... } 
.................... void deco_tramaRx() 
.................... { 
....................   numero=0; 
*
049A:  CLRF   xB2
....................   fin_pal=65; 
049C:  MOVLW  41
049E:  MOVWF  xB3
....................   dat_comp=0; 
04A0:  CLRF   xB4
....................   j=0; 
04A2:  CLRF   xB5
....................   for(m=8;m<=fin_pal;m++) 
04A4:  MOVLW  08
04A6:  MOVWF  xB7
04A8:  MOVF   xB7,W
04AA:  SUBWF  xB3,W
04AC:  BTFSS  FD8.0
04AE:  BRA    0870
....................   { 
....................    if((dato_rx[m]=='&')&&(dat_comp==1)) 
04B0:  CLRF   03
04B2:  MOVF   xB7,W
04B4:  ADDLW  84
04B6:  MOVWF  FE9
04B8:  MOVLW  00
04BA:  ADDWFC 03,W
04BC:  MOVWF  FEA
04BE:  MOVF   FEF,W
04C0:  SUBLW  26
04C2:  BNZ   04D0
04C4:  DECFSZ xB4,W
04C6:  BRA    04D0
....................    { 
....................     dat_comp=1; 
04C8:  MOVLW  01
04CA:  MOVWF  xB4
....................     fin_pal=m; 
04CC:  MOVFF  B7,B3
....................    } 
....................    if ((dato_rx[m]!='+')&& (dato_rx[m]!='&')) 
04D0:  CLRF   03
04D2:  MOVF   xB7,W
04D4:  ADDLW  84
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVF   FEF,W
04E0:  SUBLW  2B
04E2:  BZ    0536
04E4:  CLRF   03
04E6:  MOVF   xB7,W
04E8:  ADDLW  84
04EA:  MOVWF  FE9
04EC:  MOVLW  00
04EE:  ADDWFC 03,W
04F0:  MOVWF  FEA
04F2:  MOVF   FEF,W
04F4:  SUBLW  26
04F6:  BZ    0536
....................    { 
....................     dato_aux[j]=dato_rx[m]; 
04F8:  CLRF   03
04FA:  MOVF   xB5,W
04FC:  ADDLW  A8
04FE:  MOVWF  01
0500:  MOVLW  00
0502:  ADDWFC 03,F
0504:  MOVLB  1
0506:  MOVFF  03,10E
050A:  CLRF   03
050C:  MOVLB  0
050E:  MOVF   xB7,W
0510:  ADDLW  84
0512:  MOVWF  FE9
0514:  MOVLW  00
0516:  ADDWFC 03,W
0518:  MOVWF  FEA
051A:  MOVFF  FEF,10F
051E:  MOVLB  1
0520:  MOVFF  10E,FEA
0524:  MOVFF  01,FE9
0528:  MOVFF  10F,FEF
....................     j=j+1; 
052C:  MOVLW  01
052E:  MOVLB  0
0530:  ADDWF  xB5,F
....................     dat_comp=0; 
0532:  CLRF   xB4
....................    } else { 
0534:  BRA    086C
....................             for(s=0;s<=2;s++) dato_aux2[s]='0'; 
0536:  CLRF   xB6
0538:  MOVF   xB6,W
053A:  SUBLW  02
053C:  BNC   0554
053E:  CLRF   03
0540:  MOVF   xB6,W
0542:  ADDLW  AD
0544:  MOVWF  FE9
0546:  MOVLW  00
0548:  ADDWFC 03,W
054A:  MOVWF  FEA
054C:  MOVLW  30
054E:  MOVWF  FEF
0550:  INCF   xB6,F
0552:  BRA    0538
....................             for(s=0;s<j;s++)  dato_aux2[(4-j)+s]=dato_aux[s]; 
0554:  CLRF   xB6
0556:  MOVF   xB5,W
0558:  SUBWF  xB6,W
055A:  BC    059E
055C:  MOVLW  04
055E:  BSF    FD8.0
0560:  SUBFWB xB5,W
0562:  ADDWF  xB6,W
0564:  CLRF   03
0566:  ADDLW  AD
0568:  MOVWF  01
056A:  MOVLW  00
056C:  ADDWFC 03,F
056E:  MOVFF  01,10D
0572:  MOVLB  1
0574:  MOVFF  03,10E
0578:  CLRF   03
057A:  MOVLB  0
057C:  MOVF   xB6,W
057E:  ADDLW  A8
0580:  MOVWF  FE9
0582:  MOVLW  00
0584:  ADDWFC 03,W
0586:  MOVWF  FEA
0588:  MOVFF  FEF,10F
058C:  MOVFF  10E,FEA
0590:  MOVFF  01,FE9
0594:  MOVFF  10F,FEF
0598:  MOVLB  0
059A:  INCF   xB6,F
059C:  BRA    0556
....................             j=0; 
059E:  CLRF   xB5
....................             if ((numero==0)&&(dat_comp!=1)) 
05A0:  MOVF   xB2,F
05A2:  BNZ   05C4
05A4:  DECFSZ xB4,W
05A6:  BRA    05AA
05A8:  BRA    05C4
....................             { 
....................               comando_rx=atoi32(dato_aux2); 
05AA:  MOVLB  1
05AC:  CLRF   x0E
05AE:  MOVLW  AD
05B0:  MOVWF  x0D
05B2:  MOVLB  0
05B4:  RCALL  01F6
05B6:  MOVFF  01,C8
05BA:  MOVFF  00,C7
....................               numero=1; dat_comp=1; 
05BE:  MOVLW  01
05C0:  MOVWF  xB2
05C2:  MOVWF  xB4
....................             } 
....................             if ((numero==1)&&(dat_comp!=1)) 
05C4:  DECFSZ xB2,W
05C6:  BRA    0656
05C8:  DECFSZ xB4,W
05CA:  BRA    05CE
05CC:  BRA    0656
....................             { 
....................              if (comando_rx==1) hora=atoi32(dato_aux2); 
05CE:  DECFSZ xC7,W
05D0:  BRA    05E6
05D2:  MOVF   xC8,F
05D4:  BNZ   05E6
05D6:  MOVLB  1
05D8:  CLRF   x0E
05DA:  MOVLW  AD
05DC:  MOVWF  x0D
05DE:  MOVLB  0
05E0:  RCALL  01F6
05E2:  MOVFF  00,BA
....................              if (comando_rx==2) hora=atoi32(dato_aux2); 
05E6:  MOVF   xC7,W
05E8:  SUBLW  02
05EA:  BNZ   0600
05EC:  MOVF   xC8,F
05EE:  BNZ   0600
05F0:  MOVLB  1
05F2:  CLRF   x0E
05F4:  MOVLW  AD
05F6:  MOVWF  x0D
05F8:  MOVLB  0
05FA:  RCALL  01F6
05FC:  MOVFF  00,BA
....................              if (comando_rx==3) hora=atoi32(dato_aux2); 
0600:  MOVF   xC7,W
0602:  SUBLW  03
0604:  BNZ   061A
0606:  MOVF   xC8,F
0608:  BNZ   061A
060A:  MOVLB  1
060C:  CLRF   x0E
060E:  MOVLW  AD
0610:  MOVWF  x0D
0612:  MOVLB  0
0614:  RCALL  01F6
0616:  MOVFF  00,BA
....................              if (comando_rx==4) hora=atoi32(dato_aux2); 
061A:  MOVF   xC7,W
061C:  SUBLW  04
061E:  BNZ   0634
0620:  MOVF   xC8,F
0622:  BNZ   0634
0624:  MOVLB  1
0626:  CLRF   x0E
0628:  MOVLW  AD
062A:  MOVWF  x0D
062C:  MOVLB  0
062E:  RCALL  01F6
0630:  MOVFF  00,BA
....................              if (comando_rx==8) hora=atoi32(dato_aux2); 
0634:  MOVF   xC7,W
0636:  SUBLW  08
0638:  BNZ   064E
063A:  MOVF   xC8,F
063C:  BNZ   064E
063E:  MOVLB  1
0640:  CLRF   x0E
0642:  MOVLW  AD
0644:  MOVWF  x0D
0646:  MOVLB  0
0648:  RCALL  01F6
064A:  MOVFF  00,BA
....................              numero=2;  
064E:  MOVLW  02
0650:  MOVWF  xB2
....................              dat_comp=1; 
0652:  MOVLW  01
0654:  MOVWF  xB4
....................             } 
....................             if ((numero==2)&&(dat_comp!=1))  
0656:  MOVF   xB2,W
0658:  SUBLW  02
065A:  BNZ   06EA
065C:  DECFSZ xB4,W
065E:  BRA    0662
0660:  BRA    06EA
....................             {  
....................              if (comando_rx==1) minutos=atoi32(dato_aux2); 
0662:  DECFSZ xC7,W
0664:  BRA    067A
0666:  MOVF   xC8,F
0668:  BNZ   067A
066A:  MOVLB  1
066C:  CLRF   x0E
066E:  MOVLW  AD
0670:  MOVWF  x0D
0672:  MOVLB  0
0674:  RCALL  01F6
0676:  MOVFF  00,BB
....................              if (comando_rx==2) minutos=atoi32(dato_aux2); 
067A:  MOVF   xC7,W
067C:  SUBLW  02
067E:  BNZ   0694
0680:  MOVF   xC8,F
0682:  BNZ   0694
0684:  MOVLB  1
0686:  CLRF   x0E
0688:  MOVLW  AD
068A:  MOVWF  x0D
068C:  MOVLB  0
068E:  RCALL  01F6
0690:  MOVFF  00,BB
....................              if (comando_rx==3) minutos=atoi32(dato_aux2); 
0694:  MOVF   xC7,W
0696:  SUBLW  03
0698:  BNZ   06AE
069A:  MOVF   xC8,F
069C:  BNZ   06AE
069E:  MOVLB  1
06A0:  CLRF   x0E
06A2:  MOVLW  AD
06A4:  MOVWF  x0D
06A6:  MOVLB  0
06A8:  RCALL  01F6
06AA:  MOVFF  00,BB
....................              if (comando_rx==4) minutos=atoi32(dato_aux2); 
06AE:  MOVF   xC7,W
06B0:  SUBLW  04
06B2:  BNZ   06C8
06B4:  MOVF   xC8,F
06B6:  BNZ   06C8
06B8:  MOVLB  1
06BA:  CLRF   x0E
06BC:  MOVLW  AD
06BE:  MOVWF  x0D
06C0:  MOVLB  0
06C2:  RCALL  01F6
06C4:  MOVFF  00,BB
....................              if (comando_rx==8) minutos=atoi32(dato_aux2); 
06C8:  MOVF   xC7,W
06CA:  SUBLW  08
06CC:  BNZ   06E2
06CE:  MOVF   xC8,F
06D0:  BNZ   06E2
06D2:  MOVLB  1
06D4:  CLRF   x0E
06D6:  MOVLW  AD
06D8:  MOVWF  x0D
06DA:  MOVLB  0
06DC:  RCALL  01F6
06DE:  MOVFF  00,BB
....................              numero=3; 
06E2:  MOVLW  03
06E4:  MOVWF  xB2
....................              dat_comp=1; 
06E6:  MOVLW  01
06E8:  MOVWF  xB4
....................             } 
....................             if ((numero==3)&&(dat_comp!=1)) 
06EA:  MOVF   xB2,W
06EC:  SUBLW  03
06EE:  BNZ   075E
06F0:  DECFSZ xB4,W
06F2:  BRA    06F6
06F4:  BRA    075E
....................             {  
....................              if (comando_rx==1) minima=atoi32(dato_aux2); 
06F6:  DECFSZ xC7,W
06F8:  BRA    070E
06FA:  MOVF   xC8,F
06FC:  BNZ   070E
06FE:  MOVLB  1
0700:  CLRF   x0E
0702:  MOVLW  AD
0704:  MOVWF  x0D
0706:  MOVLB  0
0708:  RCALL  01F6
070A:  MOVFF  00,BC
....................              if (comando_rx==2)hora_inicio=atoi32(dato_aux2); 
070E:  MOVF   xC7,W
0710:  SUBLW  02
0712:  BNZ   0728
0714:  MOVF   xC8,F
0716:  BNZ   0728
0718:  MOVLB  1
071A:  CLRF   x0E
071C:  MOVLW  AD
071E:  MOVWF  x0D
0720:  MOVLB  0
0722:  RCALL  01F6
0724:  MOVFF  00,BE
....................              if (comando_rx==3); 
0728:  MOVF   xC7,W
072A:  SUBLW  03
072C:  BNZ   0732
072E:  MOVF   xC8,F
0730:  BZ    0732
....................              if (comando_rx==4) manual=atoi32(dato_aux2); 
0732:  MOVF   xC7,W
0734:  SUBLW  04
0736:  BNZ   074C
0738:  MOVF   xC8,F
073A:  BNZ   074C
073C:  MOVLB  1
073E:  CLRF   x0E
0740:  MOVLW  AD
0742:  MOVWF  x0D
0744:  MOVLB  0
0746:  RCALL  01F6
0748:  MOVFF  00,C6
....................              if(comando_rx==8); 
074C:  MOVF   xC7,W
074E:  SUBLW  08
0750:  BNZ   0756
0752:  MOVF   xC8,F
0754:  BZ    0756
....................              numero=4;  
0756:  MOVLW  04
0758:  MOVWF  xB2
....................              dat_comp=1; 
075A:  MOVLW  01
075C:  MOVWF  xB4
....................             } 
....................             if ((numero==4)&&(dat_comp!=1)) 
075E:  MOVF   xB2,W
0760:  SUBLW  04
0762:  BNZ   07C2
0764:  DECFSZ xB4,W
0766:  BRA    076A
0768:  BRA    07C2
....................             { 
....................              if (comando_rx==1)maxima=atoi32(dato_aux2); 
076A:  DECFSZ xC7,W
076C:  BRA    0782
076E:  MOVF   xC8,F
0770:  BNZ   0782
0772:  MOVLB  1
0774:  CLRF   x0E
0776:  MOVLW  AD
0778:  MOVWF  x0D
077A:  MOVLB  0
077C:  RCALL  01F6
077E:  MOVFF  00,BD
....................              if (comando_rx==2)minutos_inicio=atoi32(dato_aux2); 
0782:  MOVF   xC7,W
0784:  SUBLW  02
0786:  BNZ   079C
0788:  MOVF   xC8,F
078A:  BNZ   079C
078C:  MOVLB  1
078E:  CLRF   x0E
0790:  MOVLW  AD
0792:  MOVWF  x0D
0794:  MOVLB  0
0796:  RCALL  01F6
0798:  MOVFF  00,BF
....................              if (comando_rx==3); 
079C:  MOVF   xC7,W
079E:  SUBLW  03
07A0:  BNZ   07A6
07A2:  MOVF   xC8,F
07A4:  BZ    07A6
....................              if (comando_rx==4); 
07A6:  MOVF   xC7,W
07A8:  SUBLW  04
07AA:  BNZ   07B0
07AC:  MOVF   xC8,F
07AE:  BZ    07B0
....................              if (comando_rx==8); 
07B0:  MOVF   xC7,W
07B2:  SUBLW  08
07B4:  BNZ   07BA
07B6:  MOVF   xC8,F
07B8:  BZ    07BA
....................              numero=5; 
07BA:  MOVLW  05
07BC:  MOVWF  xB2
....................              dat_comp=1; 
07BE:  MOVLW  01
07C0:  MOVWF  xB4
....................             } 
....................             if ((numero==5)&&(dat_comp!=1)) 
07C2:  MOVF   xB2,W
07C4:  SUBLW  05
07C6:  BNZ   0816
07C8:  DECFSZ xB4,W
07CA:  BRA    07CE
07CC:  BRA    0816
....................             { 
....................              if (comando_rx==1); 
07CE:  DECFSZ xC7,W
07D0:  BRA    07D6
07D2:  MOVF   xC8,F
07D4:  BZ    07D6
....................              if (comando_rx==2) hora_fin=atoi32(dato_aux2); 
07D6:  MOVF   xC7,W
07D8:  SUBLW  02
07DA:  BNZ   07F0
07DC:  MOVF   xC8,F
07DE:  BNZ   07F0
07E0:  MOVLB  1
07E2:  CLRF   x0E
07E4:  MOVLW  AD
07E6:  MOVWF  x0D
07E8:  MOVLB  0
07EA:  RCALL  01F6
07EC:  MOVFF  00,C0
....................              if (comando_rx==3); 
07F0:  MOVF   xC7,W
07F2:  SUBLW  03
07F4:  BNZ   07FA
07F6:  MOVF   xC8,F
07F8:  BZ    07FA
....................              if (comando_rx==4); 
07FA:  MOVF   xC7,W
07FC:  SUBLW  04
07FE:  BNZ   0804
0800:  MOVF   xC8,F
0802:  BZ    0804
....................              if (comando_rx==8); 
0804:  MOVF   xC7,W
0806:  SUBLW  08
0808:  BNZ   080E
080A:  MOVF   xC8,F
080C:  BZ    080E
....................              numero=6; 
080E:  MOVLW  06
0810:  MOVWF  xB2
....................              dat_comp=1; 
0812:  MOVLW  01
0814:  MOVWF  xB4
....................             } 
....................             if ((numero==6)&&(dat_comp!=1)) 
0816:  MOVF   xB2,W
0818:  SUBLW  06
081A:  BNZ   086C
081C:  DECFSZ xB4,W
081E:  BRA    0822
0820:  BRA    086C
....................             { 
....................              if (comando_rx==1); 
0822:  DECFSZ xC7,W
0824:  BRA    082A
0826:  MOVF   xC8,F
0828:  BZ    082A
....................              if (comando_rx==2)minutos_fin=atoi32(dato_aux2); 
082A:  MOVF   xC7,W
082C:  SUBLW  02
082E:  BNZ   0844
0830:  MOVF   xC8,F
0832:  BNZ   0844
0834:  MOVLB  1
0836:  CLRF   x0E
0838:  MOVLW  AD
083A:  MOVWF  x0D
083C:  MOVLB  0
083E:  RCALL  01F6
0840:  MOVFF  00,C1
....................              if (comando_rx==3) ; 
0844:  MOVF   xC7,W
0846:  SUBLW  03
0848:  BNZ   084E
084A:  MOVF   xC8,F
084C:  BZ    084E
....................              if (comando_rx==4); 
084E:  MOVF   xC7,W
0850:  SUBLW  04
0852:  BNZ   0858
0854:  MOVF   xC8,F
0856:  BZ    0858
....................              if (comando_rx==8); 
0858:  MOVF   xC7,W
085A:  SUBLW  08
085C:  BNZ   0862
085E:  MOVF   xC8,F
0860:  BZ    0862
....................              numero=0; 
0862:  CLRF   xB2
....................              dat_comp=1;fin_pal=m; 
0864:  MOVLW  01
0866:  MOVWF  xB4
0868:  MOVFF  B7,B3
....................             } 
....................        }  
086C:  INCF   xB7,F
086E:  BRA    04A8
....................     } 
0870:  GOTO   14BE (RETURN)
.................... } 
....................  
.................... void ciclo_histeresis_control_tiempo()  
.................... { 
....................  if ((valor_humedad[0]!=0)&&(valor_humedad[1]!=0))  humedad_ciclo_uno=((valor_humedad[0]+valor_humedad[1])/2); 
*
1564:  MOVF   39,F
1566:  BNZ   156C
1568:  MOVF   3A,F
156A:  BZ    1594
156C:  MOVF   3B,F
156E:  BNZ   1574
1570:  MOVF   3C,F
1572:  BZ    1594
1574:  MOVF   3B,W
1576:  ADDWF  39,W
1578:  MOVLB  1
157A:  MOVWF  x0D
157C:  MOVF   3C,W
157E:  ADDWFC 3A,W
1580:  MOVWF  x0E
1582:  BCF    FD8.0
1584:  RRCF   x0E,W
1586:  MOVLB  0
1588:  MOVWF  xD0
158A:  MOVLB  1
158C:  RRCF   x0D,W
158E:  MOVLB  0
1590:  MOVWF  xCF
1592:  BRA    15B6
....................     else if(valor_humedad[0]==0) humedad_ciclo_uno=valor_humedad[1]; 
1594:  MOVF   39,F
1596:  BNZ   15A6
1598:  MOVF   3A,F
159A:  BNZ   15A6
159C:  MOVFF  3C,D0
15A0:  MOVFF  3B,CF
15A4:  BRA    15B6
....................                     else if(valor_humedad[1]==0) humedad_ciclo_uno=valor_humedad[0]; 
15A6:  MOVF   3B,F
15A8:  BNZ   15B6
15AA:  MOVF   3C,F
15AC:  BNZ   15B6
15AE:  MOVFF  3A,D0
15B2:  MOVFF  39,CF
....................  
....................  if ((valor_humedad[2]!=0)&&(valor_humedad[3]!=0))  humedad_ciclo_dos=((valor_humedad[2]+valor_humedad[3])/2); 
15B6:  MOVF   3D,F
15B8:  BNZ   15BE
15BA:  MOVF   3E,F
15BC:  BZ    15E6
15BE:  MOVF   3F,F
15C0:  BNZ   15C6
15C2:  MOVF   40,F
15C4:  BZ    15E6
15C6:  MOVF   3F,W
15C8:  ADDWF  3D,W
15CA:  MOVLB  1
15CC:  MOVWF  x0D
15CE:  MOVF   40,W
15D0:  ADDWFC 3E,W
15D2:  MOVWF  x0E
15D4:  BCF    FD8.0
15D6:  RRCF   x0E,W
15D8:  MOVLB  0
15DA:  MOVWF  xD2
15DC:  MOVLB  1
15DE:  RRCF   x0D,W
15E0:  MOVLB  0
15E2:  MOVWF  xD1
15E4:  BRA    1608
....................     else if(valor_humedad[2]==0) humedad_ciclo_dos=valor_humedad[3]; 
15E6:  MOVF   3D,F
15E8:  BNZ   15F8
15EA:  MOVF   3E,F
15EC:  BNZ   15F8
15EE:  MOVFF  40,D2
15F2:  MOVFF  3F,D1
15F6:  BRA    1608
....................                     else if(valor_humedad[3]==0) humedad_ciclo_dos=valor_humedad[2]; 
15F8:  MOVF   3F,F
15FA:  BNZ   1608
15FC:  MOVF   40,F
15FE:  BNZ   1608
1600:  MOVFF  3E,D2
1604:  MOVFF  3D,D1
....................  ///////////CICLO DE HISTERESIS SENSOR UNO////////////////////////////////////////////////////////////////////////////// 
....................   
....................  if ( humedad_ciclo_uno<minima) 
1608:  MOVF   xD0,F
160A:  BNZ   1618
160C:  MOVF   xBC,W
160E:  SUBWF  xCF,W
1610:  BC    1618
....................  { 
....................   regando_1=1; 
1612:  MOVLW  01
1614:  MOVWF  59
....................   sube_1=1; 
1616:  MOVWF  5E
....................  } 
....................  if ( humedad_ciclo_uno>maxima) 
1618:  MOVF   xD0,F
161A:  BNZ   1622
161C:  MOVF   xCF,W
161E:  SUBWF  xBD,W
1620:  BC    1628
....................  { 
....................   regando_1=0; 
1622:  CLRF   59
....................   baja_1=1; 
1624:  MOVLW  01
1626:  MOVWF  x62
....................  } 
....................  if (minima<= humedad_ciclo_uno<=maxima)  
1628:  MOVF   xD0,F
162A:  BNZ   1636
162C:  MOVF   xBC,W
162E:  SUBWF  xCF,W
1630:  BC    1636
1632:  MOVLW  00
1634:  BRA    1638
1636:  MOVLW  01
1638:  SUBWF  xBD,W
163A:  BNC   164E
....................  { 
....................   if (sube_1==1){regando_1=1; sube_1=0;} 
163C:  DECFSZ 5E,W
163E:  BRA    1646
1640:  MOVLW  01
1642:  MOVWF  59
1644:  CLRF   5E
....................   if (baja_1==1){regando_1=0; ;baja_1=0; } 
1646:  DECFSZ x62,W
1648:  BRA    164E
164A:  CLRF   59
164C:  CLRF   x62
....................  }   
.................... ///////////CICLO DE HISTERESIS SENSOR DOS////////////////////////////////////////////////////////////////////////////////   
....................  if (humedad_ciclo_dos<minima) 
164E:  MOVF   xD2,F
1650:  BNZ   165E
1652:  MOVF   xBC,W
1654:  SUBWF  xD1,W
1656:  BC    165E
....................  { 
....................   regando_2=1; 
1658:  MOVLW  01
165A:  MOVWF  5A
....................   sube_2=1; 
165C:  MOVWF  5F
....................  } 
....................  if ( humedad_ciclo_dos>maxima) 
165E:  MOVF   xD2,F
1660:  BNZ   1668
1662:  MOVF   xD1,W
1664:  SUBWF  xBD,W
1666:  BC    166E
....................  { 
....................   regando_2=0; 
1668:  CLRF   5A
....................   baja_2=1; 
166A:  MOVLW  01
166C:  MOVWF  x63
....................  } 
....................  if (minima<= humedad_ciclo_dos<=maxima)  
166E:  MOVF   xD2,F
1670:  BNZ   167C
1672:  MOVF   xBC,W
1674:  SUBWF  xD1,W
1676:  BC    167C
1678:  MOVLW  00
167A:  BRA    167E
167C:  MOVLW  01
167E:  SUBWF  xBD,W
1680:  BNC   1694
....................  { 
....................   if (sube_2==1){regando_2=1; sube_2=0;} 
1682:  DECFSZ 5F,W
1684:  BRA    168C
1686:  MOVLW  01
1688:  MOVWF  5A
168A:  CLRF   5F
....................   if (baja_2==1){regando_2=0; ;baja_2=0; } 
168C:  DECFSZ x63,W
168E:  BRA    1694
1690:  CLRF   5A
1692:  CLRF   x63
....................  }   
....................  if (minima==maxima) 
1694:  MOVF   xBD,W
1696:  SUBWF  xBC,W
1698:  BNZ   169E
....................  { 
....................   regando_1=0; 
169A:  CLRF   59
....................   regando_2=0; 
169C:  CLRF   5A
....................  } 
....................  if ((valor_humedad[0]==0)&&(valor_humedad[1]==0))regando_1=0; 
169E:  MOVF   39,F
16A0:  BNZ   16B0
16A2:  MOVF   3A,F
16A4:  BNZ   16B0
16A6:  MOVF   3B,F
16A8:  BNZ   16B0
16AA:  MOVF   3C,F
16AC:  BNZ   16B0
16AE:  CLRF   59
....................  if ((valor_humedad[2]==0)&&(valor_humedad[3]==0))regando_2=0; 
16B0:  MOVF   3D,F
16B2:  BNZ   16C2
16B4:  MOVF   3E,F
16B6:  BNZ   16C2
16B8:  MOVF   3F,F
16BA:  BNZ   16C2
16BC:  MOVF   40,F
16BE:  BNZ   16C2
16C0:  CLRF   5A
.................... /////////////////////////////CONTRO POR TIEMPO////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  if (((hora>=0)&&(hora<=23)&&(minutos>=0)&&(minutos<=60)&&(hora_inicio>=0)&&(hora_inicio<=23)&&(minutos_inicio>=0)&&(minutos_inicio<=60)&& 
....................                              (hora_fin>=0)&&(hora_fin<=23)&&(minutos_fin>=0)&&(minutos_fin<=60))) 
16C2:  MOVF   xBA,W
16C4:  SUBLW  17
16C6:  BNC   1704
16C8:  MOVF   xBB,W
16CA:  SUBLW  3C
16CC:  BNC   1704
16CE:  MOVF   xBE,W
16D0:  SUBLW  17
16D2:  BNC   1704
16D4:  MOVF   xBF,W
16D6:  SUBLW  3C
16D8:  BNC   1704
16DA:  MOVF   xC0,W
16DC:  SUBLW  17
16DE:  BNC   1704
16E0:  MOVF   xC1,W
16E2:  SUBLW  3C
16E4:  BNC   1704
....................  { 
....................   if ((hora==hora_inicio)&&(minutos==minutos_inicio))  regando_t=1; 
16E6:  MOVF   xBE,W
16E8:  SUBWF  xBA,W
16EA:  BNZ   16F6
16EC:  MOVF   xBF,W
16EE:  SUBWF  xBB,W
16F0:  BNZ   16F6
16F2:  MOVLW  01
16F4:  MOVWF  5D
....................   if ((hora==hora_fin)&&(minutos==minutos_fin))        regando_t=0; 
16F6:  MOVF   xC0,W
16F8:  SUBWF  xBA,W
16FA:  BNZ   1704
16FC:  MOVF   xC1,W
16FE:  SUBWF  xBB,W
1700:  BNZ   1704
1702:  CLRF   5D
....................  }  
1704:  GOTO   17B6 (RETURN)
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... } 
....................  
.................... //#task(rate = 250ms) 
.................... //void maquina_de_estado_display(); 
.................... #task(rate = 5ms) 
.................... void maquina_de_estado_de_aplicacion(); 
.................... #task(rate = 5ms) 
.................... void maquina_de_estado_de_comunicacion(); 
.................... void main() 
*
19B8:  CLRF   FF8
19BA:  BCF    FD0.7
19BC:  BSF    07.7
19BE:  BCF    F95.3
19C0:  BCF    F8C.3
19C2:  BSF    FB8.3
19C4:  MOVLW  08
19C6:  MOVWF  FAF
19C8:  MOVLW  02
19CA:  MOVWF  FB0
19CC:  MOVLW  A6
19CE:  MOVWF  FAC
19D0:  MOVLW  90
19D2:  MOVWF  FAB
19D4:  CLRF   56
19D6:  CLRF   55
19D8:  CLRF   58
19DA:  CLRF   57
19DC:  CLRF   59
19DE:  CLRF   5A
19E0:  CLRF   5B
19E2:  CLRF   5C
19E4:  CLRF   5D
19E6:  CLRF   5E
19E8:  CLRF   5F
19EA:  CLRF   x60
19EC:  CLRF   x61
19EE:  CLRF   x62
19F0:  CLRF   x63
19F2:  CLRF   x64
19F4:  CLRF   x65
19F6:  CLRF   xB2
19F8:  CLRF   xB3
19FA:  CLRF   xB4
19FC:  CLRF   xB5
19FE:  CLRF   xB6
1A00:  CLRF   xB7
1A02:  MOVLW  01
1A04:  MOVWF  xB8
1A06:  CLRF   xB9
1A08:  CLRF   xBA
1A0A:  CLRF   xBB
1A0C:  CLRF   xBC
1A0E:  CLRF   xBD
1A10:  CLRF   xBE
1A12:  CLRF   xBF
1A14:  CLRF   xC0
1A16:  CLRF   xC1
1A18:  CLRF   xC6
1A1A:  CLRF   xC8
1A1C:  MOVLW  0A
1A1E:  MOVWF  xC7
1A20:  CLRF   xCA
1A22:  MOVLW  01
1A24:  MOVWF  xC9
1A26:  CLRF   xCC
1A28:  CLRF   xCB
1A2A:  CLRF   xCE
1A2C:  CLRF   xCD
1A2E:  CLRF   xD0
1A30:  CLRF   xCF
1A32:  CLRF   xD2
1A34:  CLRF   xD1
1A36:  CLRF   xD3
1A38:  CLRF   xD4
1A3A:  CLRF   xD5
1A3C:  CLRF   xD6
1A3E:  CLRF   xD7
1A40:  CLRF   xD8
1A42:  CLRF   xD9
1A44:  CLRF   xDA
1A46:  CLRF   xDC
1A48:  CLRF   xDB
1A4A:  MOVF   FC1,W
1A4C:  ANDLW  C0
1A4E:  IORLW  0F
1A50:  MOVWF  FC1
1A52:  MOVLW  07
1A54:  MOVWF  FB4
1A56:  CLRF   32
1A58:  CLRF   33
.................... { 
....................  enable_interrupts(INT_RDA); 
1A5A:  BSF    F9D.5
....................  enable_interrupts(GLOBAL); 
1A5C:  MOVLW  C0
1A5E:  IORWF  FF2,F
....................  desactivar_rele(PIN_C1); 
1A60:  MOVLW  11
1A62:  MOVLB  1
1A64:  MOVWF  x0D
1A66:  MOVLB  0
1A68:  RCALL  1776
....................  desactivar_rele(PIN_C2); 
1A6A:  MOVLW  12
1A6C:  MOVLB  1
1A6E:  MOVWF  x0D
1A70:  MOVLB  0
1A72:  RCALL  1776
....................  setup_counters(RTCC_INTERNAL,RTCC_DIV_32); 
1A74:  BCF    FD1.0
1A76:  MOVLW  84
1A78:  MOVWF  FD5
....................  delay_us(10); 
1A7A:  MOVLW  10
1A7C:  MOVWF  00
1A7E:  DECFSZ 00,F
1A80:  BRA    1A7E
1A82:  NOP   
....................  rtos_run(); 
1A84:  CLRF   xDD
1A86:  CLRF   xDF
1A88:  MOVLW  01
1A8A:  MOVWF  xDE
1A8C:  CLRF   xE1
1A8E:  CLRF   xE0
1A90:  MOVLW  A0
1A92:  MOVWF  xE2
1A94:  MOVLW  17
1A96:  MOVWF  xE3
1A98:  CLRF   xE4
1A9A:  CLRF   xE6
1A9C:  MOVLW  01
1A9E:  MOVWF  xE5
1AA0:  CLRF   xE8
1AA2:  CLRF   xE7
1AA4:  MOVLW  D2
1AA6:  MOVWF  xE9
1AA8:  MOVLW  13
1AAA:  MOVWF  xEA
1AAC:  CLRF   38
1AAE:  MOVLW  88
1AB0:  MOVWF  FD5
1AB2:  MOVLW  9E
1AB4:  MOVWF  FD7
1AB6:  MOVLW  58
1AB8:  MOVWF  FD6
1ABA:  BCF    FF2.2
1ABC:  BCF    FD8.0
1ABE:  RLCF   38,W
1AC0:  MOVWF  00
1AC2:  CALL   00BA
1AC6:  MOVWF  02
1AC8:  MOVLW  01
1ACA:  ADDWF  00,W
1ACC:  CALL   00BA
1AD0:  MOVWF  03
1AD2:  MOVFF  03,FEA
1AD6:  MOVFF  02,FE9
1ADA:  MOVFF  FEF,02
1ADE:  INCF   FE9,F
1AE0:  MOVFF  FEF,00
1AE4:  MOVFF  FEC,01
1AE8:  INCF   FEC,F
1AEA:  MOVFF  FEF,03
1AEE:  BNZ   1AF4
1AF0:  INCF   FEC,F
1AF2:  MOVF   FED,F
1AF4:  MOVF   FEC,W
1AF6:  SUBWF  01,W
1AF8:  BNZ   1B1A
1AFA:  MOVF   00,W
1AFC:  SUBWF  03,W
1AFE:  BNZ   1B1A
1B00:  MOVF   FED,F
1B02:  CLRF   FEE
1B04:  CLRF   FEF
1B06:  BTFSC  02.7
1B08:  BRA    1B1A
1B0A:  MOVF   FEC,F
1B0C:  MOVFF  FEC,FFA
1B10:  MOVF   FED,F
1B12:  MOVFF  FEF,FE8
1B16:  MOVWF  FF9
1B18:  MOVLB  0
1B1A:  INCF   38,F
1B1C:  MOVLW  02
1B1E:  SUBWF  38,W
1B20:  BNZ   1ABC
1B22:  CLRF   38
1B24:  MOVF   FD6,W
1B26:  MOVFF  FD7,03
1B2A:  BTFSC  FF2.2
1B2C:  BRA    1AB2
1B2E:  BRA    1B24
1B30:  SETF   38
.................... } 
.................... void maquina_de_estado_de_comunicacion() 
1B32:  SLEEP 
.................... { 
....................  switch (estado_siguiente){ 
*
13D2:  MOVF   xB8,W
13D4:  XORLW  01
13D6:  BZ    13E4
13D8:  XORLW  03
13DA:  BZ    14A6
13DC:  XORLW  01
13DE:  BTFSC  FD8.2
13E0:  BRA    14F6
13E2:  BRA    1556
....................   case STATE_INI: 
....................     delay_ms(150); 
13E4:  MOVLW  96
13E6:  MOVLB  1
13E8:  MOVWF  x0D
13EA:  MOVLB  0
13EC:  CALL   011A
....................     UTRDIS = 1;  
13F0:  BSF    F6F.3
....................     adc_init();  
13F2:  GOTO   0142
....................    // lcd_init(); 
....................     dato_rx[0]='1'; 
13F6:  MOVLW  31
13F8:  MOVWF  x84
....................     dato_rx[1]='1'; 
13FA:  MOVWF  x85
....................     dato_rx[2]='1'; 
13FC:  MOVWF  x86
....................     dato_rx[3]='1'; 
13FE:  MOVWF  x87
....................     dato_rx[4]='1'; 
1400:  MOVWF  x88
....................     dato_rx[5]='1'; 
1402:  MOVWF  x89
....................     dato_rx[6]='1'; 
1404:  MOVWF  x8A
....................     dato_rx[7]='1'; 
1406:  MOVWF  x8B
....................     AN_0=10;AN_1=20;AN_2=30;AN_3=40; 
1408:  CLRF   17
140A:  MOVLW  0A
140C:  MOVWF  16
140E:  CLRF   19
1410:  MOVLW  14
1412:  MOVWF  18
1414:  CLRF   1B
1416:  MOVLW  1E
1418:  MOVWF  1A
141A:  CLRF   1D
141C:  MOVLW  28
141E:  MOVWF  1C
....................     AN0_V=0;AN1_V=0;AN2_V=0;AN3_V=0; 
1420:  CLRF   21
1422:  CLRF   20
1424:  CLRF   1F
1426:  CLRF   1E
1428:  CLRF   25
142A:  CLRF   24
142C:  CLRF   23
142E:  CLRF   22
1430:  CLRF   29
1432:  CLRF   28
1434:  CLRF   27
1436:  CLRF   26
1438:  CLRF   2D
143A:  CLRF   2C
143C:  CLRF   2B
143E:  CLRF   2A
....................     hum_i_1=0;hum_i_2=0;hum_i_3=0;hum_i_4=0; 
1440:  CLRF   42
1442:  CLRF   41
1444:  CLRF   44
1446:  CLRF   43
1448:  CLRF   46
144A:  CLRF   45
144C:  CLRF   48
144E:  CLRF   47
....................     hum_f_1=0,hum_f_2=0,hum_f_3=0,hum_f_4=0; 
1450:  CLRF   4A
1452:  CLRF   49
1454:  CLRF   4C
1456:  CLRF   4B
1458:  CLRF   4E
145A:  CLRF   4D
145C:  CLRF   50
145E:  CLRF   4F
....................     regando_1=0;regando_2=0,regando_3=0,regando_4=0,regando_t=0; 
1460:  CLRF   59
1462:  CLRF   5A
1464:  CLRF   5B
1466:  CLRF   5C
1468:  CLRF   5D
....................     sube_1=0;sube_2=0;sube_3=0;sube_4=0; 
146A:  CLRF   5E
146C:  CLRF   5F
146E:  CLRF   x60
1470:  CLRF   x61
....................     baja_1=0;baja_2=0;baja_3=0;baja_4=0; 
1472:  CLRF   x62
1474:  CLRF   x63
1476:  CLRF   x64
1478:  CLRF   x65
....................     item=0; 
147A:  CLRF   52
147C:  CLRF   51
....................     n_menus =4; 
147E:  CLRF   54
1480:  MOVLW  04
1482:  MOVWF  53
....................     estado_siguiente=STATE_ACTIVO; 
1484:  MOVLW  03
1486:  MOVWF  xB8
....................     salida[0]=0;salida[1]=0;salida[2]=0;salida[3]=0; 
1488:  CLRF   xC2
148A:  CLRF   xC3
148C:  CLRF   xC4
148E:  CLRF   xC5
....................     minima=0;maxima=0; 
1490:  CLRF   xBC
1492:  CLRF   xBD
....................     valor_humedad[0]=0; 
1494:  CLRF   3A
1496:  CLRF   39
....................     valor_humedad[1]=0; 
1498:  CLRF   3C
149A:  CLRF   3B
....................     valor_humedad[2]=0; 
149C:  CLRF   3E
149E:  CLRF   3D
....................     valor_humedad[3]=0; 
14A0:  CLRF   40
14A2:  CLRF   3F
....................   break; 
14A4:  BRA    1556
....................   case STATE_SEND: 
....................     dato_completo=0; 
14A6:  CLRF   58
14A8:  CLRF   57
....................     envio_dato(); 
14AA:  GOTO   01AA
....................     while(dato_completo=!1) 
14AE:  CLRF   58
14B0:  CLRF   57
14B2:  MOVF   57,W
14B4:  IORWF  58,W
14B6:  BZ    14BA
....................     {} 
14B8:  BRA    14AE
....................     deco_tramaRx(); 
14BA:  GOTO   049A
....................     if (comando_rx==3) comando_tx=1; 
14BE:  MOVF   xC7,W
14C0:  SUBLW  03
14C2:  BNZ   14CE
14C4:  MOVF   xC8,F
14C6:  BNZ   14CE
14C8:  CLRF   xCA
14CA:  MOVLW  01
14CC:  MOVWF  xC9
....................     if (comando_rx==1) comando_tx=1; 
14CE:  DECFSZ xC7,W
14D0:  BRA    14DC
14D2:  MOVF   xC8,F
14D4:  BNZ   14DC
14D6:  CLRF   xCA
14D8:  MOVLW  01
14DA:  MOVWF  xC9
....................     if (comando_rx==8) comando_tx=2; 
14DC:  MOVF   xC7,W
14DE:  SUBLW  08
14E0:  BNZ   14EC
14E2:  MOVF   xC8,F
14E4:  BNZ   14EC
14E6:  CLRF   xCA
14E8:  MOVLW  02
14EA:  MOVWF  xC9
....................     dato_completo=0; 
14EC:  CLRF   58
14EE:  CLRF   57
....................     estado_siguiente=STATE_ACTIVO; 
14F0:  MOVLW  03
14F2:  MOVWF  xB8
....................   break; 
14F4:  BRA    1556
....................   case STATE_ACTIVO: 
....................     leer_ADC0_ADC1_ADC2_ADC3(); 
14F6:  GOTO   0874
....................     convertir_ADC0_ADC1_ADC2_ADC3_a_tension(); 
14FA:  GOTO   0B92
....................     convertir_ADC0_ADC1_ADC2_ADC3_a_porcentaje(); 
14FE:  BRA    0D92
....................     valor_humedad[0] = AN_0_porcentaje; 
1500:  CLRF   3A
1502:  MOVFF  2E,39
....................     valor_humedad[1]  = AN_1_porcentaje; 
1506:  CLRF   3C
1508:  MOVFF  2F,3B
....................     valor_humedad[2] = AN_2_porcentaje; 
150C:  CLRF   3E
150E:  MOVFF  30,3D
....................     valor_humedad[3]= AN_3_porcentaje; 
1512:  CLRF   40
1514:  MOVFF  31,3F
....................     if ((dato_rx[0]=='0') && (dato_rx[1]=='0')&& (dato_rx[2]=='0') && (dato_rx[3]=='0')&& 
....................                      (dato_rx[4]=='0') && (dato_rx[5]=='0')&& (dato_rx[6]=='0') && (dato_rx[7]=='1')&&( dato_completo==1) ) 
1518:  MOVF   x84,W
151A:  SUBLW  30
151C:  BNZ   1556
151E:  MOVF   x85,W
1520:  SUBLW  30
1522:  BNZ   1556
1524:  MOVF   x86,W
1526:  SUBLW  30
1528:  BNZ   1556
152A:  MOVF   x87,W
152C:  SUBLW  30
152E:  BNZ   1556
1530:  MOVF   x88,W
1532:  SUBLW  30
1534:  BNZ   1556
1536:  MOVF   x89,W
1538:  SUBLW  30
153A:  BNZ   1556
153C:  MOVF   x8A,W
153E:  SUBLW  30
1540:  BNZ   1556
1542:  MOVF   x8B,W
1544:  SUBLW  31
1546:  BNZ   1556
1548:  DECFSZ 57,W
154A:  BRA    1556
154C:  MOVF   58,F
154E:  BNZ   1556
....................     { 
....................      armar_trama(); 
1550:  BRA    114E
....................      estado_siguiente=STATE_SEND; 
1552:  MOVLW  02
1554:  MOVWF  xB8
....................    //lcd_putc('\f'); 
....................    //if (dato_completo==1) 
....................    //{ 
....................    //for(m=8;m<=fin;m++) 
....................    //{ 
....................    //lcd_gotoxy(1,1); 
....................    //if(dato_rx[m]=='&')m=fin; 
....................    //lcd_putc(dato_rx[m]); 
....................    //} 
....................    //} 
....................    //delay_ms(500); 
....................    //} 
....................   break; 
....................   } 
....................  } 
1556:  MOVLW  D2
1558:  MOVWF  xE9
155A:  MOVLW  13
155C:  MOVWF  xEA
155E:  GOTO   1B18
1562:  RETURN 0
.................... } 
.................... //void maquina_de_estado_display() 
.................... //{ 
.................... // if (lee_pulsador(PIN_C4)==1) 
.................... // { 
.................... //  item++; 
.................... //  delay_ms(300); 
.................... // } 
.................... // if (item > (n_menus-1)) item=0; 
.................... //        switch (item) { 
.................... //           case 0:printf(lcd_putc,"\fADC0 =%4u",tipo_riego);  
.................... //                  printf(lcd_putc,"\nVoltaje = %01.2fv",AN0_v);  
.................... //                  break; 
.................... //           case 1:printf(lcd_putc,"\fADC1 =%4u",maxima); 
.................... //                  printf(lcd_putc,"\nVoltaje = %01.2fv",AN1_v); 
.................... //                  break;  
.................... //           case 2:printf(lcd_putc,"\fADC2 =%4ld",valor_humedad[2]); 
.................... //                  printf(lcd_putc,"\nVoltaje = %01.2fv",AN2_v);  
.................... //                  break; 
.................... //           case 3:printf(lcd_putc,"\fADC3 =%4ld",valor_humedad[3]); 
.................... //                  printf(lcd_putc,"\nVoltaje = %01.2fv",AN3_v); 
.................... //                  break; 
.................... //                      } 
.................... //} 
....................  
.................... void maquina_de_estado_de_aplicacion() 
.................... { 
....................  switch (estado_siguiente_riego){ 
*
17A0:  MOVF   xB9,W
17A2:  ADDLW  F9
17A4:  BTFSC  FD8.0
17A6:  BRA    1978
17A8:  ADDLW  07
17AA:  GOTO   1986
....................   case STATE_INICIAL: 
....................     estado_siguiente_riego=STATE_ACT; 
17AE:  MOVLW  01
17B0:  MOVWF  xB9
....................   break; 
17B2:  BRA    1978
....................   case STATE_ACT : 
....................     ciclo_histeresis_control_tiempo(); 
17B4:  BRA    1564
....................     if ((regando_t!=regando_t_anterior)) estado_siguiente_riego=STATE_TIEMPO; 
17B6:  MOVF   xDA,W
17B8:  SUBWF  5D,W
17BA:  BZ    17C0
17BC:  MOVLW  03
17BE:  MOVWF  xB9
....................     if ((manual==11)||(manual==13)||(manual==12)||(manual==44)||((manual==45)&&(entro_manual==0))||((manual==46)&&(entro_manual==1))) estado_siguiente_riego=STATE_MANUAL; 
17C0:  MOVF   xC6,W
17C2:  SUBLW  0B
17C4:  BZ    17EC
17C6:  MOVF   xC6,W
17C8:  SUBLW  0D
17CA:  BZ    17EC
17CC:  MOVF   xC6,W
17CE:  SUBLW  0C
17D0:  BZ    17EC
17D2:  MOVF   xC6,W
17D4:  SUBLW  2C
17D6:  BZ    17EC
17D8:  MOVF   xC6,W
17DA:  SUBLW  2D
17DC:  BNZ   17E2
17DE:  MOVF   xD7,F
17E0:  BZ    17EC
17E2:  MOVF   xC6,W
17E4:  SUBLW  2E
17E6:  BNZ   17F0
17E8:  DECFSZ xD7,W
17EA:  BRA    17F0
17EC:  MOVLW  02
17EE:  MOVWF  xB9
....................     if((regando_1!=regando_1_anterior)||(regando_2!=regando_2_anterior))estado_siguiente_riego=STATE_HUMEDAD; 
17F0:  MOVF   xD8,W
17F2:  SUBWF  59,W
17F4:  BNZ   17FC
17F6:  MOVF   xD9,W
17F8:  SUBWF  5A,W
17FA:  BZ    1800
17FC:  MOVLW  04
17FE:  MOVWF  xB9
....................     regando_1_anterior=regando_1; 
1800:  MOVFF  59,D8
....................     regando_2_anterior=regando_2; 
1804:  MOVFF  5A,D9
....................     regando_t_anterior=regando_t; 
1808:  MOVFF  5D,DA
....................   break; 
180C:  BRA    1978
....................   case STATE_MANUAL:  
....................     if ((manual==11)||(manual==13)||(manual==12)) estado_siguiente_riego=STATE_ACTIVAR_VALVULA; 
180E:  MOVF   xC6,W
1810:  SUBLW  0B
1812:  BZ    1820
1814:  MOVF   xC6,W
1816:  SUBLW  0D
1818:  BZ    1820
181A:  MOVF   xC6,W
181C:  SUBLW  0C
181E:  BNZ   1824
1820:  MOVLW  05
1822:  MOVWF  xB9
....................     if ((manual==44)) estado_siguiente_riego=STATE_DESACTIVAR_VALVULA; 
1824:  MOVF   xC6,W
1826:  SUBLW  2C
1828:  BNZ   182E
182A:  MOVLW  06
182C:  MOVWF  xB9
....................     if ((manual==45)&&(entro_manual==0)) 
182E:  MOVF   xC6,W
1830:  SUBLW  2D
1832:  BNZ   184C
1834:  MOVF   xD7,F
1836:  BNZ   184C
....................     { 
....................      minima_guardada=minima; 
1838:  MOVFF  BC,D5
....................      maxima_guardada=maxima; 
183C:  MOVFF  BD,D6
....................      minima=0; 
1840:  CLRF   xBC
....................      maxima=0; 
1842:  CLRF   xBD
....................      entro_manual=1; 
1844:  MOVLW  01
1846:  MOVWF  xD7
....................      estado_siguiente_riego=STATE_DESACTIVAR_VALVULA; 
1848:  MOVLW  06
184A:  MOVWF  xB9
....................     } 
....................     if ((manual==46)) 
184C:  MOVF   xC6,W
184E:  SUBLW  2E
1850:  BNZ   1860
....................     { 
....................      minima=minima_guardada; 
1852:  MOVFF  D5,BC
....................      maxima=maxima_guardada; 
1856:  MOVFF  D6,BD
....................      estado_siguiente_riego=STATE_DESACTIVAR_VALVULA; 
185A:  MOVLW  06
185C:  MOVWF  xB9
....................      entro_manual=0; 
185E:  CLRF   xD7
....................     } 
....................     tipo_riego=2; 
1860:  MOVLW  02
1862:  MOVWF  xD3
....................     tipo_riego_anterior=tipo_riego; 
1864:  MOVFF  D3,D4
....................   break; 
1868:  BRA    1978
....................   case STATE_TIEMPO: 
....................     if  (regando_t==1) estado_siguiente_riego=STATE_ACTIVAR_VALVULA; 
186A:  DECFSZ 5D,W
186C:  BRA    1872
186E:  MOVLW  05
1870:  MOVWF  xB9
....................     if  (regando_t==0) estado_siguiente_riego=STATE_DESACTIVAR_VALVULA; 
1872:  MOVF   5D,F
1874:  BNZ   187A
1876:  MOVLW  06
1878:  MOVWF  xB9
....................     tipo_riego=3; 
187A:  MOVLW  03
187C:  MOVWF  xD3
....................   break; 
187E:  BRA    1978
....................   case STATE_HUMEDAD: 
....................     if((regando_1==1)||(regando_2==1)) estado_siguiente_riego=STATE_ACTIVAR_VALVULA; 
1880:  DECFSZ 59,W
1882:  BRA    1886
1884:  BRA    188A
1886:  DECFSZ 5A,W
1888:  BRA    188E
188A:  MOVLW  05
188C:  MOVWF  xB9
....................     if((regando_1==0)&&(regando_2==0))estado_siguiente_riego=STATE_DESACTIVAR_VALVULA;//aca&& 
188E:  MOVF   59,F
1890:  BNZ   189A
1892:  MOVF   5A,F
1894:  BNZ   189A
1896:  MOVLW  06
1898:  MOVWF  xB9
....................     if ( tipo_riego_anterior==2) tipo_riego=2; else tipo_riego=1; 
189A:  MOVF   xD4,W
189C:  SUBLW  02
189E:  BNZ   18A6
18A0:  MOVLW  02
18A2:  MOVWF  xD3
18A4:  BRA    18AA
18A6:  MOVLW  01
18A8:  MOVWF  xD3
....................     tipo_riego_anterior=1; 
18AA:  MOVLW  01
18AC:  MOVWF  xD4
....................  break; 
18AE:  BRA    1978
....................   case STATE_ACTIVAR_VALVULA: 
....................     if((regando_1==1)||(regando_t==1)||(manual==11)||(manual==13)) 
18B0:  DECFSZ 59,W
18B2:  BRA    18B6
18B4:  BRA    18C8
18B6:  DECFSZ 5D,W
18B8:  BRA    18BC
18BA:  BRA    18C8
18BC:  MOVF   xC6,W
18BE:  SUBLW  0B
18C0:  BZ    18C8
18C2:  MOVF   xC6,W
18C4:  SUBLW  0D
18C6:  BNZ   18D8
....................     { 
....................      activar_rele(PIN_C1); 
18C8:  MOVLW  11
18CA:  MOVLB  1
18CC:  MOVWF  x0D
18CE:  MOVLB  0
18D0:  RCALL  174A
....................      estado_valvula_1_placa_1=1; 
18D2:  CLRF   xCC
18D4:  MOVLW  01
18D6:  MOVWF  xCB
....................     } 
....................     if ((regando_2==1)||(regando_t==1)||(manual==12)||(manual==13)) 
18D8:  DECFSZ 5A,W
18DA:  BRA    18DE
18DC:  BRA    18F0
18DE:  DECFSZ 5D,W
18E0:  BRA    18E4
18E2:  BRA    18F0
18E4:  MOVF   xC6,W
18E6:  SUBLW  0C
18E8:  BZ    18F0
18EA:  MOVF   xC6,W
18EC:  SUBLW  0D
18EE:  BNZ   1900
....................     { 
....................      activar_rele(PIN_C2); 
18F0:  MOVLW  12
18F2:  MOVLB  1
18F4:  MOVWF  x0D
18F6:  MOVLB  0
18F8:  RCALL  174A
....................      estado_valvula_2_placa_1=1; 
18FA:  CLRF   xCE
18FC:  MOVLW  01
18FE:  MOVWF  xCD
....................     } 
....................     if (tipo_riego==1) estado_siguiente_riego=STATE_DESACTIVAR_VALVULA; else estado_siguiente_riego=STATE_ACT; 
1900:  DECFSZ xD3,W
1902:  BRA    190A
1904:  MOVLW  06
1906:  MOVWF  xB9
1908:  BRA    190E
190A:  MOVLW  01
190C:  MOVWF  xB9
....................   break; 
190E:  BRA    1978
....................   case STATE_DESACTIVAR_VALVULA: 
....................     if(((regando_1!=1)&&(regando_t!=1)&&(manual!=11)&&(manual!=13))||((manual==44)||(manual==45))) 
1910:  DECFSZ 59,W
1912:  BRA    1916
1914:  BRA    1928
1916:  DECFSZ 5D,W
1918:  BRA    191C
191A:  BRA    1928
191C:  MOVF   xC6,W
191E:  SUBLW  0B
1920:  BZ    1928
1922:  MOVF   xC6,W
1924:  SUBLW  0D
1926:  BNZ   1934
1928:  MOVF   xC6,W
192A:  SUBLW  2C
192C:  BZ    1934
192E:  MOVF   xC6,W
1930:  SUBLW  2D
1932:  BNZ   1942
....................     { 
....................      desactivar_rele(PIN_C1); 
1934:  MOVLW  11
1936:  MOVLB  1
1938:  MOVWF  x0D
193A:  MOVLB  0
193C:  RCALL  1776
....................      estado_valvula_1_placa_1=0; 
193E:  CLRF   xCC
1940:  CLRF   xCB
....................     } 
....................     if (((regando_2!=1)&&(regando_t!=1)&&(manual!=12)&&(manual!=13))||((manual==44)||(manual==45))) 
1942:  DECFSZ 5A,W
1944:  BRA    1948
1946:  BRA    195A
1948:  DECFSZ 5D,W
194A:  BRA    194E
194C:  BRA    195A
194E:  MOVF   xC6,W
1950:  SUBLW  0C
1952:  BZ    195A
1954:  MOVF   xC6,W
1956:  SUBLW  0D
1958:  BNZ   1966
195A:  MOVF   xC6,W
195C:  SUBLW  2C
195E:  BZ    1966
1960:  MOVF   xC6,W
1962:  SUBLW  2D
1964:  BNZ   1974
....................     { 
....................      desactivar_rele(PIN_C2); 
1966:  MOVLW  12
1968:  MOVLB  1
196A:  MOVWF  x0D
196C:  MOVLB  0
196E:  RCALL  1776
....................      estado_valvula_2_placa_1=0; 
1970:  CLRF   xCE
1972:  CLRF   xCD
....................     } 
....................       estado_siguiente_riego=STATE_ACT; 
1974:  MOVLW  01
1976:  MOVWF  xB9
....................      
....................     break; 
....................     } 
1978:  MOVLW  A0
197A:  MOVWF  xE2
197C:  MOVLW  17
197E:  MOVWF  xE3
1980:  GOTO   1B18
1984:  RETURN 0
.................... } 
....................  

Configuration Fuses:
   Word  1: CC00   PLL1 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
